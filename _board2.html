<!DOCTYPE html>
<html>

<head>
	<base target="_parent">
	<script>
		/*! jQuery v3.5.1 | (c) JS Foundation and other contributors | jquery.org/license */
		!function (e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return t(e) } : t(e) }("undefined" != typeof window ? window : this, function (C, e) { "use strict"; var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat ? function (e) { return t.flat.call(e) } : function (e) { return t.concat.apply([], e) }, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call(Object), y = {}, m = function (e) { return "function" == typeof e && "number" != typeof e.nodeType }, x = function (e) { return null != e && e === e.window }, E = C.document, c = { type: !0, src: !0, nonce: !0, noModule: !0 }; function b(e, t, n) { var r, i, o = (n = n || E).createElement("script"); if (o.text = e, t) for (r in c) (i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i); n.head.appendChild(o).parentNode.removeChild(o) } function w(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e } var f = "3.5.1", S = function (e, t) { return new S.fn.init(e, t) }; function p(e) { var t = !!e && "length" in e && e.length, n = w(e); return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e) } S.fn = S.prototype = { jquery: f, constructor: S, length: 0, toArray: function () { return s.call(this) }, get: function (e) { return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = S.merge(this.constructor(), e); return t.prevObject = this, t }, each: function (e) { return S.each(this, e) }, map: function (n) { return this.pushStack(S.map(this, function (e, t) { return n.call(e, t, e) })) }, slice: function () { return this.pushStack(s.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, even: function () { return this.pushStack(S.grep(this, function (e, t) { return (t + 1) % 2 })) }, odd: function () { return this.pushStack(S.grep(this, function (e, t) { return t % 2 })) }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(0 <= n && n < t ? [this[n]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: u, sort: t.sort, splice: t.splice }, S.extend = S.fn.extend = function () { var e, t, n, r, i, o, a = arguments[0] || {}, s = 1, u = arguments.length, l = !1; for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)if (null != (e = arguments[s])) for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r)); return a }, S.extend({ expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, n; return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof (n = v.call(t, "constructor") && t.constructor) && a.call(n) === l) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, globalEval: function (e, t, n) { b(e, { nonce: t && t.nonce }, n) }, each: function (e, t) { var n, r = 0; if (p(e)) { for (n = e.length; r < n; r++)if (!1 === t.call(e[r], r, e[r])) break } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e }, makeArray: function (e, t) { var n = t || []; return null != e && (p(Object(e)) ? S.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n }, inArray: function (e, t, n) { return null == t ? -1 : i.call(t, e, n) }, merge: function (e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r]; return e.length = i, e }, grep: function (e, t, n) { for (var r = [], i = 0, o = e.length, a = !n; i < o; i++)!t(e[i], i) !== a && r.push(e[i]); return r }, map: function (e, t, n) { var r, i, o = 0, a = []; if (p(e)) for (r = e.length; o < r; o++)null != (i = t(e[o], o, n)) && a.push(i); else for (o in e) null != (i = t(e[o], o, n)) && a.push(i); return g(a) }, guid: 1, support: y }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) { n["[object " + t + "]"] = t.toLowerCase() }); var d = function (n) { var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = "sizzle" + 1 * new Date, p = n.document, k = 0, r = 0, m = ue(), x = ue(), A = ue(), N = ue(), D = function (e, t) { return e === t && (l = !0), 0 }, j = {}.hasOwnProperty, t = [], q = t.pop, L = t.push, H = t.push, O = t.slice, P = function (e, t) { for (var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n; return -1 }, R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M = "[\\x20\\t\\r\\n\\f]", I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]", F = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)", B = new RegExp(M + "+", "g"), $ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"), _ = new RegExp("^" + M + "*," + M + "*"), z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"), U = new RegExp(M + "|>"), X = new RegExp(F), V = new RegExp("^" + I + "$"), G = { ID: new RegExp("^#(" + I + ")"), CLASS: new RegExp("^\\.(" + I + ")"), TAG: new RegExp("^(" + I + "|[*])"), ATTR: new RegExp("^" + W), PSEUDO: new RegExp("^" + F), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + R + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") }, Y = /HTML$/i, Q = /^(?:input|select|textarea|button)$/i, J = /^h\d$/i, K = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee = /[+~]/, te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"), ne = function (e, t) { var n = "0x" + e.slice(1) - 65536; return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)) }, re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ie = function (e, t) { return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e }, oe = function () { T() }, ae = be(function (e) { return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase() }, { dir: "parentNode", next: "legend" }); try { H.apply(t = O.call(p.childNodes), p.childNodes), t[p.childNodes.length].nodeType } catch (e) { H = { apply: t.length ? function (e, t) { L.apply(e, O.call(t)) } : function (e, t) { var n = e.length, r = 0; while (e[n++] = t[r++]); e.length = n - 1 } } } function se(t, e, n, r) { var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e ? e.nodeType : 9; if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n; if (!r && (T(e), e = e || C, E)) { if (11 !== p && (u = Z.exec(t))) if (i = u[1]) { if (9 === p) { if (!(a = e.getElementById(i))) return n; if (a.id === i) return n.push(a), n } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n } else { if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n; if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n } if (d.qsa && !N[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) { if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) { (f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = S)), o = (l = h(t)).length; while (o--) l[o] = (s ? "#" + s : ":scope") + " " + xe(l[o]); c = l.join(",") } try { return H.apply(n, f.querySelectorAll(c)), n } catch (e) { N(t, !0) } finally { s === S && e.removeAttribute("id") } } } return g(t.replace($, "$1"), e, n, r) } function ue() { var r = []; return function e(t, n) { return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n } } function le(e) { return e[S] = !0, e } function ce(e) { var t = C.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } } function fe(e, t) { var n = e.split("|"), r = n.length; while (r--) b.attrHandle[n[r]] = t } function pe(e, t) { var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return -1; return e ? 1 : -1 } function de(t) { return function (e) { return "input" === e.nodeName.toLowerCase() && e.type === t } } function he(n) { return function (e) { var t = e.nodeName.toLowerCase(); return ("input" === t || "button" === t) && e.type === n } } function ge(t) { return function (e) { return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t } } function ve(a) { return le(function (o) { return o = +o, le(function (e, t) { var n, r = a([], e.length, o), i = r.length; while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n])) }) }) } function ye(e) { return e && "undefined" != typeof e.getElementsByTagName && e } for (e in d = se.support = {}, i = se.isXML = function (e) { var t = e.namespaceURI, n = (e.ownerDocument || e).documentElement; return !Y.test(t || n && n.nodeName || "HTML") }, T = se.setDocument = function (e) { var t, n, r = e ? e.ownerDocument || e : p; return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.scope = ce(function (e) { return a.appendChild(e).appendChild(C.createElement("div")), "undefined" != typeof e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length }), d.attributes = ce(function (e) { return e.className = "i", !e.getAttribute("className") }), d.getElementsByTagName = ce(function (e) { return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function (e) { return a.appendChild(e).id = S, !C.getElementsByName || !C.getElementsByName(S).length }), d.getById ? (b.filter.ID = function (e) { var t = e.replace(te, ne); return function (e) { return e.getAttribute("id") === t } }, b.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && E) { var n = t.getElementById(e); return n ? [n] : [] } }) : (b.filter.ID = function (e) { var n = e.replace(te, ne); return function (e) { var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id"); return t && t.value === n } }, b.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && E) { var n, r, i, o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode("id")) && n.value === e) return [o]; i = t.getElementsByName(e), r = 0; while (o = i[r++]) if ((n = o.getAttributeNode("id")) && n.value === e) return [o] } return [] } }), b.find.TAG = d.getElementsByTagName ? function (e, t) { return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0 } : function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName(e); if ("*" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r } return o }, b.find.CLASS = d.getElementsByClassName && function (e, t) { if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e) }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function (e) { var t; a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + S + "-]").length || v.push("~="), (t = C.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + S + "+*").length || v.push(".#.+[+~]"), e.querySelectorAll("\\\f"), v.push("[\\r\\n\\f]") }), ce(function (e) { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var t = C.createElement("input"); t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:") })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) { d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", F) }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function (e, t) { var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function (e, t) { if (t) while (t = t.parentNode) if (t === e) return !0; return !1 }, D = t ? function (e, t) { if (e === t) return l = !0, 0; var n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1) } : function (e, t) { if (e === t) return l = !0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (!i || !o) return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0; if (i === o) return pe(e, t); n = e; while (n = n.parentNode) a.unshift(n); n = t; while (n = n.parentNode) s.unshift(n); while (a[r] === s[r]) r++; return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ? 1 : 0 }), C }, se.matches = function (e, t) { return se(e, null, null, t) }, se.matchesSelector = function (e, t) { if (T(e), d.matchesSelector && E && !N[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try { var n = c.call(e, t); if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n } catch (e) { N(t, !0) } return 0 < se(t, C, null, [e]).length }, se.contains = function (e, t) { return (e.ownerDocument || e) != C && T(e), y(e, t) }, se.attr = function (e, t) { (e.ownerDocument || e) != C && T(e); var n = b.attrHandle[t.toLowerCase()], r = n && j.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0; return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }, se.escape = function (e) { return (e + "").replace(re, ie) }, se.error = function (e) { throw new Error("Syntax error, unrecognized expression: " + e) }, se.uniqueSort = function (e) { var t, n = [], r = 0, i = 0; if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(D), l) { while (t = e[i++]) t === e[i] && (r = n.push(i)); while (r--) e.splice(n[r], 1) } return u = null, e }, o = se.getText = function (e) { var t, n = "", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += o(e) } else if (3 === i || 4 === i) return e.nodeValue } else while (t = e[r++]) n += o(t); return n }, (b = se.selectors = { cacheLength: 50, createPseudo: le, match: G, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e }, PSEUDO: function (e) { var t, n = !e[6] && e[2]; return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { var t = e.replace(te, ne).toLowerCase(); return "*" === e ? function () { return !0 } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS: function (e) { var t = m[e + " "]; return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && m(e, function (e) { return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "") }) }, ATTR: function (n, r, i) { return function (e) { var t = se.attr(e, n); return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-")) } }, CHILD: function (h, e, t, g, v) { var y = "nth" !== h.slice(0, 3), m = "last" !== h.slice(-4), x = "of-type" === e; return 1 === g && 0 === v ? function (e) { return !!e.parentNode } : function (e, t, n) { var r, i, o, a, s, u, l = y !== m ? "nextSibling" : "previousSibling", c = e.parentNode, f = x && e.nodeName.toLowerCase(), p = !n && !x, d = !1; if (c) { if (y) { while (l) { a = e; while (a = a[l]) if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1; u = l = "only" === h && !u && "nextSibling" } return !0 } if (u = [m ? c.firstChild : c.lastChild], m && p) { d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2], a = s && c.childNodes[s]; while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if (1 === a.nodeType && ++d && a === e) { i[h] = [k, s, d]; break } } else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d) while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [k, d]), a === e)) break; return (d -= v) === g || d % g == 0 && 0 <= d / g } } }, PSEUDO: function (e, o) { var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e); return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function (e, t) { var n, r = a(e, o), i = r.length; while (i--) e[n = P(e, r[i])] = !(t[n] = r[i]) }) : function (e) { return a(e, 0, t) }) : a } }, pseudos: { not: le(function (e) { var r = [], i = [], s = f(e.replace($, "$1")); return s[S] ? le(function (e, t, n, r) { var i, o = s(e, null, r, []), a = e.length; while (a--) (i = o[a]) && (e[a] = !(t[a] = i)) }) : function (e, t, n) { return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop() } }), has: le(function (t) { return function (e) { return 0 < se(t, e).length } }), contains: le(function (t) { return t = t.replace(te, ne), function (e) { return -1 < (e.textContent || o(e)).indexOf(t) } }), lang: le(function (n) { return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(), function (e) { var t; do { if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-") } while ((e = e.parentNode) && 1 === e.nodeType); return !1 } }), target: function (e) { var t = n.location && n.location.hash; return t && t.slice(1) === e.id }, root: function (e) { return e === a }, focus: function (e) { return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled: ge(!1), disabled: ge(!0), checked: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0 }, parent: function (e) { return !b.pseudos.empty(e) }, header: function (e) { return J.test(e.nodeName) }, input: function (e) { return Q.test(e.nodeName) }, button: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t }, text: function (e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) }, first: ve(function () { return [0] }), last: ve(function (e, t) { return [t - 1] }), eq: ve(function (e, t, n) { return [n < 0 ? n + t : n] }), even: ve(function (e, t) { for (var n = 0; n < t; n += 2)e.push(n); return e }), odd: ve(function (e, t) { for (var n = 1; n < t; n += 2)e.push(n); return e }), lt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;)e.push(r); return e }), gt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : n; ++r < t;)e.push(r); return e }) } }).pseudos.nth = b.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) b.pseudos[e] = de(e); for (e in { submit: !0, reset: !0 }) b.pseudos[e] = he(e); function me() { } function xe(e) { for (var t = 0, n = e.length, r = ""; t < n; t++)r += e[t].value; return r } function be(s, e, t) { var u = e.dir, l = e.next, c = l || u, f = t && "parentNode" === c, p = r++; return e.first ? function (e, t, n) { while (e = e[u]) if (1 === e.nodeType || f) return s(e, t, n); return !1 } : function (e, t, n) { var r, i, o, a = [k, p]; if (n) { while (e = e[u]) if ((1 === e.nodeType || f) && s(e, t, n)) return !0 } else while (e = e[u]) if (1 === e.nodeType || f) if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e; else { if ((r = i[c]) && r[0] === k && r[1] === p) return a[2] = r[2]; if ((i[c] = a)[2] = s(e, t, n)) return !0 } return !1 } } function we(i) { return 1 < i.length ? function (e, t, n) { var r = i.length; while (r--) if (!i[r](e, t, n)) return !1; return !0 } : i[0] } function Te(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a } function Ce(d, h, g, v, y, e) { return v && !v[S] && (v = Ce(v)), y && !y[S] && (y = Ce(y, e)), le(function (e, t, n, r) { var i, o, a, s = [], u = [], l = t.length, c = e || function (e, t, n) { for (var r = 0, i = t.length; r < i; r++)se(e, t[r], n); return n }(h || "*", n.nodeType ? [n] : n, []), f = !d || !e && h ? c : Te(c, s, d, n, r), p = g ? y || (e ? d : l || v) ? [] : t : f; if (g && g(f, p, n, r), v) { i = Te(p, u), v(i, [], n, r), o = i.length; while (o--) (a = i[o]) && (p[u[o]] = !(f[u[o]] = a)) } if (e) { if (y || d) { if (y) { i = [], o = p.length; while (o--) (a = p[o]) && i.push(f[o] = a); y(null, p = [], i, r) } o = p.length; while (o--) (a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a)) } } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p) }) } function Ee(e) { for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function (e) { return e === i }, a, !0), l = be(function (e) { return -1 < P(i, e) }, a, !0), c = [function (e, t, n) { var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n)); return i = null, r }]; s < r; s++)if (t = b.relative[e[s].type]) c = [be(we(c), t)]; else { if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) { for (n = ++s; n < r; n++)if (b.relative[e[n].type]) break; return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({ value: " " === e[s - 2].type ? "*" : "" })).replace($, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e)) } c.push(t) } return we(c) } return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) { var n, r, i, o, a, s, u, l = x[e + " "]; if (l) return t ? 0 : l.slice(0); a = e, s = [], u = b.preFilter; while (a) { for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({ value: n, type: r[0].replace($, " ") }), a = a.slice(n.length)), b.filter) !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({ value: n, type: o, matches: r }), a = a.slice(n.length)); if (!n) break } return t ? a.length : a ? se.error(e) : x(e, s).slice(0) }, f = se.compile = function (e, t) { var n, v, y, m, x, r, i = [], o = [], a = A[e + " "]; if (!a) { t || (t = h(e)), n = t.length; while (n--) (a = Ee(t[n]))[S] ? i.push(a) : o.push(a); (a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function (e, t, n, r, i) { var o, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find.TAG("*", i), h = k += null == p ? 1 : Math.random() || .1, g = d.length; for (i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++) { if (x && o) { a = 0, t || o.ownerDocument == C || (T(o), n = !E); while (s = v[a++]) if (s(o, t || C, n)) { r.push(o); break } i && (k = h) } m && ((o = !s && o) && u--, e && c.push(o)) } if (u += l, m && l !== u) { a = 0; while (s = y[a++]) s(c, f, t, n); if (e) { if (0 < u) while (l--) c[l] || f[l] || (f[l] = q.call(r)); f = Te(f) } H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r) } return i && (k = h, w = p), c }, m ? le(r) : r))).selector = e } return a }, g = se.select = function (e, t, n, r) { var i, o, a, s, u, l = "function" == typeof e && e, c = !r && h(e = l.selector || e); if (n = n || [], 1 === c.length) { if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) { if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n; l && (t = t.parentNode), e = e.slice(o.shift().value.length) } i = G.needsContext.test(e) ? 0 : o.length; while (i--) { if (a = o[i], b.relative[s = a.type]) break; if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) { if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n; break } } } return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n }, d.sortStable = S.split("").sort(D).join("") === S, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function (e) { return 1 & e.compareDocumentPosition(C.createElement("fieldset")) }), ce(function (e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href") }) || fe("type|href|height|width", function (e, t, n) { if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2) }), d.attributes && ce(function (e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value") }) || fe("value", function (e, t, n) { if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue }), ce(function (e) { return null == e.getAttribute("disabled") }) || fe(R, function (e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }), se }(C); S.find = d, S.expr = d.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape; var h = function (e, t, n) { var r = [], i = void 0 !== n; while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) { if (i && S(e).is(n)) break; r.push(e) } return r }, T = function (e, t) { for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n }, k = S.expr.match.needsContext; function A(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function D(e, n, r) { return m(n) ? S.grep(e, function (e, t) { return !!n.call(e, t, e) !== r }) : n.nodeType ? S.grep(e, function (e) { return e === n !== r }) : "string" != typeof n ? S.grep(e, function (e) { return -1 < i.call(n, e) !== r }) : S.filter(n, e, r) } S.filter = function (e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [r] : [] : S.find.matches(e, S.grep(t, function (e) { return 1 === e.nodeType })) }, S.fn.extend({ find: function (e) { var t, n, r = this.length, i = this; if ("string" != typeof e) return this.pushStack(S(e).filter(function () { for (t = 0; t < r; t++)if (S.contains(i[t], this)) return !0 })); for (n = this.pushStack([]), t = 0; t < r; t++)S.find(e, i[t], n); return 1 < r ? S.uniqueSort(n) : n }, filter: function (e) { return this.pushStack(D(this, e || [], !1)) }, not: function (e) { return this.pushStack(D(this, e || [], !0)) }, is: function (e) { return !!D(this, "string" == typeof e && k.test(e) ? S(e) : e || [], !1).length } }); var j, q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (S.fn.init = function (e, t, n) { var r, i; if (!e) return this; if (n = n || j, "string" == typeof e) { if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (r[1]) { if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t)) for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]); return this } return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this) }).prototype = S.fn, j = S(E); var L = /^(?:parents|prev(?:Until|All))/, H = { children: !0, contents: !0, next: !0, prev: !0 }; function O(e, t) { while ((e = e[t]) && 1 !== e.nodeType); return e } S.fn.extend({ has: function (e) { var t = S(e, this), n = t.length; return this.filter(function () { for (var e = 0; e < n; e++)if (S.contains(this, t[e])) return !0 }) }, closest: function (e, t) { var n, r = 0, i = this.length, o = [], a = "string" != typeof e && S(e); if (!k.test(e)) for (; r < i; r++)for (n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) { o.push(n); break } return this.pushStack(1 < o.length ? S.uniqueSort(o) : o) }, index: function (e) { return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t)))) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }), S.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function (e) { return h(e, "parentNode") }, parentsUntil: function (e, t, n) { return h(e, "parentNode", n) }, next: function (e) { return O(e, "nextSibling") }, prev: function (e) { return O(e, "previousSibling") }, nextAll: function (e) { return h(e, "nextSibling") }, prevAll: function (e) { return h(e, "previousSibling") }, nextUntil: function (e, t, n) { return h(e, "nextSibling", n) }, prevUntil: function (e, t, n) { return h(e, "previousSibling", n) }, siblings: function (e) { return T((e.parentNode || {}).firstChild, e) }, children: function (e) { return T(e.firstChild) }, contents: function (e) { return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes)) } }, function (r, i) { S.fn[r] = function (e, t) { var n = S.map(this, i, e); return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = S.filter(t, n)), 1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n) } }); var P = /[^\x20\t\r\n\f]+/g; function R(e) { return e } function M(e) { throw e } function I(e, t, n, r) { var i; try { e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)) } catch (e) { n.apply(void 0, [e]) } } S.Callbacks = function (r) { var e, n; r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(P) || [], function (e, t) { n[t] = !0 }), n) : S.extend({}, r); var i, t, o, a, s = [], u = [], l = -1, c = function () { for (a = a || r.once, o = i = !0; u.length; l = -1) { t = u.shift(); while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1) } r.memory || (t = !1), i = !1, a && (s = t ? [] : "") }, f = { add: function () { return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) { S.each(e, function (e, t) { m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t) }) }(arguments), t && !i && c()), this }, remove: function () { return S.each(arguments, function (e, t) { var n; while (-1 < (n = S.inArray(t, s, n))) s.splice(n, 1), n <= l && l-- }), this }, has: function (e) { return e ? -1 < S.inArray(e, s) : 0 < s.length }, empty: function () { return s && (s = []), this }, disable: function () { return a = u = [], s = t = "", this }, disabled: function () { return !s }, lock: function () { return a = u = [], t || i || (s = t = ""), this }, locked: function () { return !!a }, fireWith: function (e, t) { return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this }, fire: function () { return f.fireWith(this, arguments), this }, fired: function () { return !!o } }; return f }, S.extend({ Deferred: function (e) { var o = [["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2], ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]], i = "pending", a = { state: function () { return i }, always: function () { return s.done(arguments).fail(arguments), this }, "catch": function (e) { return a.then(null, e) }, pipe: function () { var i = arguments; return S.Deferred(function (r) { S.each(o, function (e, t) { var n = m(i[t[4]]) && i[t[4]]; s[t[1]](function () { var e = n && n.apply(this, arguments); e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments) }) }), i = null }).promise() }, then: function (t, n, r) { var u = 0; function l(i, o, a, s) { return function () { var n = this, r = arguments, e = function () { var e, t; if (!(i < u)) { if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution"); t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [e]), (s || o.resolveWith)(n, r)) } }, t = s ? e : function () { try { e() } catch (e) { S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== M && (n = void 0, r = [e]), o.rejectWith(n, r)) } }; i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t)) } } return S.Deferred(function (e) { o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : R)), o[2][3].add(l(0, e, m(n) ? n : M)) }).promise() }, promise: function (e) { return null != e ? S.extend(e, a) : a } }, s = {}; return S.each(o, function (e, t) { var n = t[2], r = t[5]; a[t[1]] = n.add, r && n.add(function () { i = r }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function () { return s[t[0] + "With"](this === s ? void 0 : this, arguments), this }, s[t[0] + "With"] = n.fireWith }), a.promise(s), e && e.call(s, s), s }, when: function (e) { var n = arguments.length, t = n, r = Array(t), i = s.call(arguments), o = S.Deferred(), a = function (t) { return function (e) { r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i) } }; if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then(); while (t--) I(i[t], a(t), o.reject); return o.promise() } }); var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; S.Deferred.exceptionHook = function (e, t) { C.console && C.console.warn && e && W.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t) }, S.readyException = function (e) { C.setTimeout(function () { throw e }) }; var F = S.Deferred(); function B() { E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), S.ready() } S.fn.ready = function (e) { return F.then(e)["catch"](function (e) { S.readyException(e) }), this }, S.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [S]) } }), S.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B)); var $ = function (e, t, n, r, i, o, a) { var s = 0, u = e.length, l = null == n; if ("object" === w(n)) for (s in i = !0, n) $(e, t, s, n[s], !0, o, a); else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) { return l.call(S(e), n) })), t)) for (; s < u; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : l ? t.call(e) : u ? t(e[0], n) : o }, _ = /^-ms-/, z = /-([a-z])/g; function U(e, t) { return t.toUpperCase() } function X(e) { return e.replace(_, "ms-").replace(z, U) } var V = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }; function G() { this.expando = S.expando + G.uid++ } G.uid = 1, G.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function (e, t, n) { var r, i = this.cache(e); if ("string" == typeof t) i[X(t)] = n; else for (r in t) i[X(r)] = t[r]; return i }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)] }, access: function (e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function (e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [t] : t.match(P) || []).length; while (n--) delete r[t[n]] } (void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !S.isEmptyObject(t) } }; var Y = new G, Q = new G, J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, K = /[A-Z]/g; function Z(e, t, n) { var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) { try { n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i) } catch (e) { } Q.set(e, t, n) } else n = void 0; return n } S.extend({ hasData: function (e) { return Q.hasData(e) || Y.hasData(e) }, data: function (e, t, n) { return Q.access(e, t, n) }, removeData: function (e, t) { Q.remove(e, t) }, _data: function (e, t, n) { return Y.access(e, t, n) }, _removeData: function (e, t) { Y.remove(e, t) } }), S.fn.extend({ data: function (n, e) { var t, r, i, o = this[0], a = o && o.attributes; if (void 0 === n) { if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) { t = a.length; while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = X(r.slice(5)), Z(o, r, i[r])); Y.set(o, "hasDataAttrs", !0) } return i } return "object" == typeof n ? this.each(function () { Q.set(this, n) }) : $(this, function (e) { var t; if (o && void 0 === e) return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ? t : void 0; this.each(function () { Q.set(this, n, e) }) }, null, e, 1 < arguments.length, null, !0) }, removeData: function (e) { return this.each(function () { Q.remove(this, e) }) } }), S.extend({ queue: function (e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || [] }, dequeue: function (e, t) { t = t || "fx"; var n = S.queue(e, t), r = n.length, i = n.shift(), o = S._queueHooks(e, t); "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function () { S.dequeue(e, t) }, o)), !r && o && o.empty.fire() }, _queueHooks: function (e, t) { var n = t + "queueHooks"; return Y.get(e, n) || Y.access(e, n, { empty: S.Callbacks("once memory").add(function () { Y.remove(e, [t + "queue", n]) }) }) } }), S.fn.extend({ queue: function (t, n) { var e = 2; return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function () { var e = S.queue(this, t, n); S._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && S.dequeue(this, t) }) }, dequeue: function (e) { return this.each(function () { S.dequeue(this, e) }) }, clearQueue: function (e) { return this.queue(e || "fx", []) }, promise: function (e, t) { var n, r = 1, i = S.Deferred(), o = this, a = this.length, s = function () { --r || i.resolveWith(o, [o]) }; "string" != typeof e && (t = e, e = void 0), e = e || "fx"; while (a--) (n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t) } }); var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"), ne = ["Top", "Right", "Bottom", "Left"], re = E.documentElement, ie = function (e) { return S.contains(e.ownerDocument, e) }, oe = { composed: !0 }; re.getRootNode && (ie = function (e) { return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument }); var ae = function (e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === S.css(e, "display") }; function se(e, t, n, r) { var i, o, a = 20, s = r ? function () { return r.cur() } : function () { return S.css(e, t, "") }, u = s(), l = n && n[3] || (S.cssNumber[t] ? "" : "px"), c = e.nodeType && (S.cssNumber[t] || "px" !== l && +u) && te.exec(S.css(e, t)); if (c && c[3] !== l) { u /= 2, l = l || c[3], c = +u || 1; while (a--) S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o; c *= 2, S.style(e, t, c + l), n = n || [] } return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i } var ue = {}; function le(e, t) { for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Y.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ue[s] = u)))) : "none" !== n && (l[c] = "none", Y.set(r, "display", n))); for (c = 0; c < f; c++)null != l[c] && (e[c].style.display = l[c]); return e } S.fn.extend({ show: function () { return le(this, !0) }, hide: function () { return le(this) }, toggle: function (e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () { ae(this) ? S(this).show() : S(this).hide() }) } }); var ce, fe, pe = /^(?:checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, he = /^$|^module$|\/(?:java|ecma)script/i; ce = E.createDocumentFragment().appendChild(E.createElement("div")), (fe = E.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = "<option></option>", y.option = !!ce.lastChild; var ge = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; function ve(e, t) { var n; return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? S.merge([e], n) : n } function ye(e, t) { for (var n = 0, r = e.length; n < r; n++)Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval")) } ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]); var me = /<|&#?\w+;/; function xe(e, t, n, r, i) { for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)if ((o = e[d]) || 0 === o) if ("object" === w(o)) S.merge(p, o.nodeType ? [o] : o); else if (me.test(o)) { a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2], c = u[0]; while (c--) a = a.lastChild; S.merge(p, a.childNodes), (a = f.firstChild).textContent = "" } else p.push(t.createTextNode(o)); f.textContent = "", d = 0; while (o = p[d++]) if (r && -1 < S.inArray(o, r)) i && i.push(o); else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) { c = 0; while (o = a[c++]) he.test(o.type || "") && n.push(o) } return f } var be = /^key/, we = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Te = /^([^.]*)(?:\.(.+)|)/; function Ce() { return !0 } function Ee() { return !1 } function Se(e, t) { return e === function () { try { return E.activeElement } catch (e) { } }() == ("focus" === t) } function ke(e, t, n, r, i, o) { var a, s; if ("object" == typeof t) { for (s in "string" != typeof n && (r = r || n, n = void 0), t) ke(e, s, n, r, t[s], o); return e } if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Ee; else if (!i) return e; return 1 === o && (a = i, (i = function (e) { return S().off(e), a.apply(this, arguments) }).guid = a.guid || (a.guid = S.guid++)), e.each(function () { S.event.add(this, t, i, r, n) }) } function Ae(e, i, o) { o ? (Y.set(e, i, !1), S.event.add(e, i, { namespace: !1, handler: function (e) { var t, n, r = Y.get(this, i); if (1 & e.isTrigger && this[i]) { if (r.length) (S.event.special[i] || {}).delegateType && e.stopPropagation(); else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n.value } else r.length && (Y.set(this, i, { value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this) }), e.stopImmediatePropagation()) } })) : void 0 === Y.get(e, i) && S.event.add(e, i, Ce) } S.event = { global: {}, add: function (t, e, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.get(t); if (V(t)) { n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(re, i), n.guid || (n.guid = S.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function (e) { return "undefined" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0 }), l = (e = (e || "").match(P) || [""]).length; while (l--) d = g = (s = Te.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && S.expr.match.needsContext.test(i), namespace: h.join(".") }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0) } }, remove: function (e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.hasData(e) && Y.get(e); if (v && (u = v.events)) { l = (t = (t || "").match(P) || [""]).length; while (l--) if (d = g = (s = Te.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) { f = S.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length; while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c)); a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d]) } else for (d in u) S.event.remove(e, d + t[l], n, r, !0); S.isEmptyObject(u) && Y.remove(e, "handle events") } }, dispatch: function (e) { var t, n, r, i, o, a, s = new Array(arguments.length), u = S.event.fix(e), l = (Y.get(this, "events") || Object.create(null))[u.type] || [], c = S.event.special[u.type] || {}; for (s[0] = u, t = 1; t < arguments.length; t++)s[t] = arguments[t]; if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) { a = S.event.handlers.call(this, u, l), t = 0; while ((i = a[t++]) && !u.isPropagationStopped()) { u.currentTarget = i.elem, n = 0; while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped()) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation())) } return c.postDispatch && c.postDispatch.call(this, u), u.result } }, handlers: function (e, t) { var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType && !("click" === e.type && 1 <= e.button)) for (; l !== this; l = l.parentNode || this)if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) { for (o = [], a = {}, n = 0; n < u; n++)void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r); o.length && s.push({ elem: l, handlers: o }) } return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s }, addProp: function (t, e) { Object.defineProperty(S.Event.prototype, t, { enumerable: !0, configurable: !0, get: m(e) ? function () { if (this.originalEvent) return e(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[t] }, set: function (e) { Object.defineProperty(this, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) } }) }, fix: function (e) { return e[S.expando] ? e : new S.Event(e) }, special: { load: { noBubble: !0 }, click: { setup: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && Ae(t, "click", Ce), !1 }, trigger: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && Ae(t, "click"), !0 }, _default: function (e) { var t = e.target; return pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click") || A(t, "a") } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, S.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, S.Event = function (e, t) { if (!(this instanceof S.Event)) return new S.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Ce : Ee, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0 }, S.Event.prototype = { constructor: S.Event, isDefaultPrevented: Ee, isPropagationStopped: Ee, isImmediatePropagationStopped: Ee, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = Ce, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = Ce, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = Ce, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, S.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, "char": !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function (e) { var t = e.button; return null == e.which && be.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && we.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which } }, S.event.addProp), S.each({ focus: "focusin", blur: "focusout" }, function (e, t) { S.event.special[e] = { setup: function () { return Ae(this, e, Se), !1 }, trigger: function () { return Ae(this, e), !0 }, delegateType: t } }), S.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (e, i) { S.event.special[e] = { delegateType: i, bindType: i, handle: function (e) { var t, n = e.relatedTarget, r = e.handleObj; return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t } } }), S.fn.extend({ on: function (e, t, n, r) { return ke(this, e, t, n, r) }, one: function (e, t, n, r) { return ke(this, e, t, n, r, 1) }, off: function (e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (i in e) this.off(i, t, e[i]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Ee), this.each(function () { S.event.remove(this, e, n, t) }) } }); var Ne = /<script|<style|<link/i, De = /checked\s*(?:[^=]|=\s*.checked.)/i, je = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function qe(e, t) { return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e } function Le(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e } function He(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e } function Oe(e, t) { var n, r, i, o, a, s; if (1 === t.nodeType) { if (Y.hasData(e) && (s = Y.get(e).events)) for (i in Y.remove(t, "handle events"), s) for (n = 0, r = s[i].length; n < r; n++)S.event.add(t, i, s[i][n]); Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a)) } } function Pe(n, r, i, o) { r = g(r); var e, t, a, s, u, l, c = 0, f = n.length, p = f - 1, d = r[0], h = m(d); if (h || 1 < f && "string" == typeof d && !y.checkClone && De.test(d)) return n.each(function (e) { var t = n.eq(e); h && (r[0] = d.call(this, e, t.html())), Pe(t, r, i, o) }); if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) { for (s = (a = S.map(ve(e, "script"), Le)).length; c < f; c++)u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, "script"))), i.call(n[c], u, c); if (s) for (l = a[a.length - 1].ownerDocument, S.map(a, He), c = 0; c < s; c++)u = a[c], he.test(u.type || "") && !Y.access(u, "globalEval") && S.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? S._evalUrl && !u.noModule && S._evalUrl(u.src, { nonce: u.nonce || u.getAttribute("nonce") }, l) : b(u.textContent.replace(je, ""), u, l)) } return n } function Re(e, t, n) { for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++)n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r)); return e } S.extend({ htmlPrefilter: function (e) { return e }, clone: function (e, t, n) { var r, i, o, a, s, u, l, c = e.cloneNode(!0), f = ie(e); if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e))) for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++)s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue); if (t) if (n) for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++)Oe(o[r], a[r]); else Oe(e, c); return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c }, cleanData: function (e) { for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++)if (V(n)) { if (t = n[Y.expando]) { if (t.events) for (r in t.events) i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle); n[Y.expando] = void 0 } n[Q.expando] && (n[Q.expando] = void 0) } } }), S.fn.extend({ detach: function (e) { return Re(this, e, !0) }, remove: function (e) { return Re(this, e) }, text: function (e) { return $(this, function (e) { return void 0 === e ? S.text(this) : this.empty().each(function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) }) }, null, e, arguments.length) }, append: function () { return Pe(this, arguments, function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || qe(this, e).appendChild(e) }) }, prepend: function () { return Pe(this, arguments, function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = qe(this, e); t.insertBefore(e, t.firstChild) } }) }, before: function () { return Pe(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this) }) }, after: function () { return Pe(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = ""); return this }, clone: function (e, t) { return e = null != e && e, t = null == t ? e : t, this.map(function () { return S.clone(this, e, t) }) }, html: function (e) { return $(this, function (e) { var t = this[0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !Ne.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) { e = S.htmlPrefilter(e); try { for (; n < r; n++)1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e); t = 0 } catch (e) { } } t && this.empty().append(e) }, null, e, arguments.length) }, replaceWith: function () { var n = []; return Pe(this, arguments, function (e) { var t = this.parentNode; S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this)) }, n) } }), S.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (e, a) { S.fn[e] = function (e) { for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++)t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get()); return this.pushStack(n) } }); var Me = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"), Ie = function (e) { var t = e.ownerDocument.defaultView; return t && t.opener || (t = C), t.getComputedStyle(e) }, We = function (e, t, n) { var r, i, o = {}; for (i in t) o[i] = e.style[i], e.style[i] = t[i]; for (i in r = n.call(e), t) e.style[i] = o[i]; return r }, Fe = new RegExp(ne.join("|"), "i"); function Be(e, t, n) { var r, i, o, a, s = e.style; return (n = n || Ie(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Me.test(a) && Fe.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a } function $e(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get } } } !function () { function e() { if (l) { u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(u).appendChild(l); var e = C.getComputedStyle(l); n = "1%" !== e.top, s = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", i = 12 === t(l.offsetWidth / 3), re.removeChild(u), l = null } } function t(e) { return Math.round(parseFloat(e)) } var n, r, i, o, a, s, u = E.createElement("div"), l = E.createElement("div"); l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend(y, { boxSizingReliable: function () { return e(), r }, pixelBoxStyles: function () { return e(), o }, pixelPosition: function () { return e(), n }, reliableMarginLeft: function () { return e(), s }, scrollboxSize: function () { return e(), i }, reliableTrDimensions: function () { var e, t, n, r; return null == a && (e = E.createElement("table"), t = E.createElement("tr"), n = E.createElement("div"), e.style.cssText = "position:absolute;left:-11111px", t.style.height = "1px", n.style.height = "9px", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = 3 < parseInt(r.height), re.removeChild(e)), a } })) }(); var _e = ["Webkit", "Moz", "ms"], ze = E.createElement("div").style, Ue = {}; function Xe(e) { var t = S.cssProps[e] || Ue[e]; return t || (e in ze ? e : Ue[e] = function (e) { var t = e[0].toUpperCase() + e.slice(1), n = _e.length; while (n--) if ((e = _e[n] + t) in ze) return e }(e) || e) } var Ve = /^(none|table(?!-c[ea]).+)/, Ge = /^--/, Ye = { position: "absolute", visibility: "hidden", display: "block" }, Qe = { letterSpacing: "0", fontWeight: "400" }; function Je(e, t, n) { var r = te.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t } function Ke(e, t, n, r, i, o) { var a = "width" === t ? 1 : 0, s = 0, u = 0; if (n === (r ? "border" : "content")) return 0; for (; a < 4; a += 2)"margin" === n && (u += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (u += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i)); return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u } function Ze(e, t, n) { var r = Ie(e), i = (!y.boxSizingReliable() || n) && "border-box" === S.css(e, "boxSizing", !1, r), o = i, a = Be(e, t, r), s = "offset" + t[0].toUpperCase() + t.slice(1); if (Me.test(a)) { if (!n) return a; a = "auto" } return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === S.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Ke(e, t, n || (i ? "border" : "content"), o, r, a) + "px" } function et(e, t, n, r, i) { return new et.prototype.init(e, t, n, r, i) } S.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = Be(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (e, t, n, r) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var i, o, a, s = X(t), u = Ge.test(t), l = e.style; if (u || (t = Xe(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t]; "string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n)) } }, css: function (e, t, n, r) { var i, o, a, s = X(t); return Ge.test(t) || (t = Xe(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = Be(e, t, r)), "normal" === i && t in Qe && (i = Qe[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i } }), S.each(["height", "width"], function (e, u) { S.cssHooks[u] = { get: function (e, t, n) { if (t) return !Ve.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Ze(e, u, n) : We(e, Ye, function () { return Ze(e, u, n) }) }, set: function (e, t, n) { var r, i = Ie(e), o = !y.scrollboxSize() && "absolute" === i.position, a = (o || n) && "border-box" === S.css(e, "boxSizing", !1, i), s = n ? Ke(e, u, n, a, i) : 0; return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Ke(e, u, "border", !1, i) - .5)), s && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = S.css(e, u)), Je(0, t, s) } } }), S.cssHooks.marginLeft = $e(y.reliableMarginLeft, function (e, t) { if (t) return (parseFloat(Be(e, "marginLeft")) || e.getBoundingClientRect().left - We(e, { marginLeft: 0 }, function () { return e.getBoundingClientRect().left })) + "px" }), S.each({ margin: "", padding: "", border: "Width" }, function (i, o) { S.cssHooks[i + o] = { expand: function (e) { for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++)n[i + ne[t] + o] = r[t] || r[t - 2] || r[0]; return n } }, "margin" !== i && (S.cssHooks[i + o].set = Je) }), S.fn.extend({ css: function (e, t) { return $(this, function (e, t, n) { var r, i, o = {}, a = 0; if (Array.isArray(t)) { for (r = Ie(e), i = t.length; a < i; a++)o[t[a]] = S.css(e, t[a], !1, r); return o } return void 0 !== n ? S.style(e, t, n) : S.css(e, t) }, e, t, 1 < arguments.length) } }), ((S.Tween = et).prototype = { constructor: et, init: function (e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? "" : "px") }, cur: function () { var e = et.propHooks[this.prop]; return e && e.get ? e.get(this) : et.propHooks._default.get(this) }, run: function (e) { var t, n = et.propHooks[this.prop]; return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : et.propHooks._default.set(this), this } }).init.prototype = et.prototype, (et.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function (e) { S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[Xe(e.prop)] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit) } } }).scrollTop = et.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, S.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, S.fx = et.prototype.init, S.fx.step = {}; var tt, nt, rt, it, ot = /^(?:toggle|show|hide)$/, at = /queueHooks$/; function st() { nt && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(st) : C.setTimeout(st, S.fx.interval), S.fx.tick()) } function ut() { return C.setTimeout(function () { tt = void 0 }), tt = Date.now() } function lt(e, t) { var n, r = 0, i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)i["margin" + (n = ne[r])] = i["padding" + n] = e; return t && (i.opacity = i.width = e), i } function ct(e, t, n) { for (var r, i = (ft.tweeners[t] || []).concat(ft.tweeners["*"]), o = 0, a = i.length; o < a; o++)if (r = i[o].call(n, t, e)) return r } function ft(o, e, t) { var n, a, r = 0, i = ft.prefilters.length, s = S.Deferred().always(function () { delete u.elem }), u = function () { if (a) return !1; for (var e = tt || ut(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++)l.tweens[r].run(n); return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1) }, l = s.promise({ elem: o, props: S.extend({}, e), opts: S.extend(!0, { specialEasing: {}, easing: S.easing._default }, t), originalProperties: e, originalOptions: t, startTime: tt || ut(), duration: t.duration, tweens: [], createTween: function (e, t) { var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing); return l.tweens.push(n), n }, stop: function (e) { var t = 0, n = e ? l.tweens.length : 0; if (a) return this; for (a = !0; t < n; t++)l.tweens[t].run(1); return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this } }), c = l.props; for (!function (e, t) { var n, r, i, o, a; for (n in e) if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && "expand" in a) for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i); else t[r] = i }(c, l.opts.specialEasing); r < i; r++)if (n = ft.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n; return S.map(c, ct, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(u, { elem: o, anim: l, queue: l.opts.queue })), l } S.Animation = S.extend(ft, { tweeners: { "*": [function (e, t) { var n = this.createTween(e, t); return se(n.elem, e, te.exec(t), n), n }] }, tweener: function (e, t) { m(e) ? (t = e, e = ["*"]) : e = e.match(P); for (var n, r = 0, i = e.length; r < i; r++)n = e[r], ft.tweeners[n] = ft.tweeners[n] || [], ft.tweeners[n].unshift(t) }, prefilters: [function (e, t, n) { var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t, p = this, d = {}, h = e.style, g = e.nodeType && ae(e), v = Y.get(e, "fxshow"); for (r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s() }), a.unqueued++, p.always(function () { p.always(function () { a.unqueued--, S.queue(e, "fx").length || a.empty.fire() }) })), t) if (i = t[r], ot.test(i)) { if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) { if ("show" !== i || !v || void 0 === v[r]) continue; g = !0 } d[r] = v && v[r] || S.style(e, r) } if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y.get(e, "display")), "none" === (c = S.css(e, "display")) && (l ? c = l : (le([e], !0), l = e.style.display || l, c = S.css(e, "display"), le([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === S.css(e, "float") && (u || (p.done(function () { h.display = l }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2] })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = Y.access(e, "fxshow", { display: l }), o && (v.hidden = !g), g && le([e], !0), p.done(function () { for (r in g || le([e]), Y.remove(e, "fxshow"), d) S.style(e, r, d[r]) })), u = ct(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0)) }], prefilter: function (e, t) { t ? ft.prefilters.unshift(e) : ft.prefilters.push(e) } }), S.speed = function (e, t, n) { var r = e && "object" == typeof e ? S.extend({}, e) : { complete: n || !n && t || m(e) && e, duration: e, easing: n && t || t && !m(t) && t }; return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () { m(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue) }, r }, S.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(ae).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function (t, e, n, r) { var i = S.isEmptyObject(t), o = S.speed(e, n, r), a = function () { var e = ft(this, S.extend({}, t), o); (i || Y.get(this, "finish")) && e.stop(!0) }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a) }, stop: function (i, e, o) { var a = function (e) { var t = e.stop; delete e.stop, t(o) }; return "string" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || "fx", []), this.each(function () { var e = !0, t = null != i && i + "queueHooks", n = S.timers, r = Y.get(this); if (t) r[t] && r[t].stop && a(r[t]); else for (t in r) r[t] && r[t].stop && at.test(t) && a(r[t]); for (t = n.length; t--;)n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1)); !e && o || S.dequeue(this, i) }) }, finish: function (a) { return !1 !== a && (a = a || "fx"), this.each(function () { var e, t = Y.get(this), n = t[a + "queue"], r = t[a + "queueHooks"], i = S.timers, o = n ? n.length : 0; for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;)i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1)); for (e = 0; e < o; e++)n[e] && n[e].finish && n[e].finish.call(this); delete t.finish }) } }), S.each(["toggle", "show", "hide"], function (e, r) { var i = S.fn[r]; S.fn[r] = function (e, t, n) { return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(lt(r, !0), e, t, n) } }), S.each({ slideDown: lt("show"), slideUp: lt("hide"), slideToggle: lt("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (e, r) { S.fn[e] = function (e, t, n) { return this.animate(r, e, t, n) } }), S.timers = [], S.fx.tick = function () { var e, t = 0, n = S.timers; for (tt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || S.fx.stop(), tt = void 0 }, S.fx.timer = function (e) { S.timers.push(e), S.fx.start() }, S.fx.interval = 13, S.fx.start = function () { nt || (nt = !0, st()) }, S.fx.stop = function () { nt = null }, S.fx.speeds = { slow: 600, fast: 200, _default: 400 }, S.fn.delay = function (r, e) { return r = S.fx && S.fx.speeds[r] || r, e = e || "fx", this.queue(e, function (e, t) { var n = C.setTimeout(e, r); t.stop = function () { C.clearTimeout(n) } }) }, rt = E.createElement("input"), it = E.createElement("select").appendChild(E.createElement("option")), rt.type = "checkbox", y.checkOn = "" !== rt.value, y.optSelected = it.selected, (rt = E.createElement("input")).value = "t", rt.type = "radio", y.radioValue = "t" === rt.value; var pt, dt = S.expr.attrHandle; S.fn.extend({ attr: function (e, t) { return $(this, S.attr, e, t, 1 < arguments.length) }, removeAttr: function (e) { return this.each(function () { S.removeAttr(this, e) }) } }), S.extend({ attr: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? pt : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r) }, attrHooks: { type: { set: function (e, t) { if (!y.radioValue && "radio" === t && A(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } }, removeAttr: function (e, t) { var n, r = 0, i = t && t.match(P); if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n) } }), pt = { set: function (e, t, n) { return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n } }, S.each(S.expr.match.bool.source.match(/\w+/g), function (e, t) { var a = dt[t] || S.find.attr; dt[t] = function (e, t, n) { var r, i, o = t.toLowerCase(); return n || (i = dt[o], dt[o] = r, r = null != a(e, t, n) ? o : null, dt[o] = i), r } }); var ht = /^(?:input|select|textarea|button)$/i, gt = /^(?:a|area)$/i; function vt(e) { return (e.match(P) || []).join(" ") } function yt(e) { return e.getAttribute && e.getAttribute("class") || "" } function mt(e) { return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || [] } S.fn.extend({ prop: function (e, t) { return $(this, S.prop, e, t, 1 < arguments.length) }, removeProp: function (e) { return this.each(function () { delete this[S.propFix[e] || e] }) } }), S.extend({ prop: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t] }, propHooks: { tabIndex: { get: function (e) { var t = S.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : ht.test(e.nodeName) || gt.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { "for": "htmlFor", "class": "className" } }), y.optSelected || (S.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { S.propFix[this.toLowerCase()] = this }), S.fn.extend({ addClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { S(this).addClass(t.call(this, e, yt(this))) }); if ((e = mt(t)).length) while (n = this[u++]) if (i = yt(n), r = 1 === n.nodeType && " " + vt(i) + " ") { a = 0; while (o = e[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " "); i !== (s = vt(r)) && n.setAttribute("class", s) } return this }, removeClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { S(this).removeClass(t.call(this, e, yt(this))) }); if (!arguments.length) return this.attr("class", ""); if ((e = mt(t)).length) while (n = this[u++]) if (i = yt(n), r = 1 === n.nodeType && " " + vt(i) + " ") { a = 0; while (o = e[a++]) while (-1 < r.indexOf(" " + o + " ")) r = r.replace(" " + o + " ", " "); i !== (s = vt(r)) && n.setAttribute("class", s) } return this }, toggleClass: function (i, t) { var o = typeof i, a = "string" === o || Array.isArray(i); return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function (e) { S(this).toggleClass(i.call(this, e, yt(this), t), t) }) : this.each(function () { var e, t, n, r; if (a) { t = 0, n = S(this), r = mt(i); while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e) } else void 0 !== i && "boolean" !== o || ((e = yt(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Y.get(this, "__className__") || "")) }) }, hasClass: function (e) { var t, n, r = 0; t = " " + e + " "; while (n = this[r++]) if (1 === n.nodeType && -1 < (" " + vt(yt(n)) + " ").indexOf(t)) return !0; return !1 } }); var xt = /\r/g; S.fn.extend({ val: function (n) { var r, e, i, t = this[0]; return arguments.length ? (i = m(n), this.each(function (e) { var t; 1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function (e) { return null == e ? "" : e + "" })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t)) })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(xt, "") : null == e ? "" : e : void 0 } }), S.extend({ valHooks: { option: { get: function (e) { var t = S.find.attr(e, "value"); return null != t ? t : vt(S.text(e)) } }, select: { get: function (e) { var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [], u = a ? o + 1 : i.length; for (r = o < 0 ? u : a ? o : 0; r < u; r++)if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) { if (t = S(n).val(), a) return t; s.push(t) } return s }, set: function (e, t) { var n, r, i = e.options, o = S.makeArray(t), a = i.length; while (a--) ((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0); return n || (e.selectedIndex = -1), o } } } }), S.each(["radio", "checkbox"], function () { S.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t) } }, y.checkOn || (S.valHooks[this].get = function (e) { return null === e.getAttribute("value") ? "on" : e.value }) }), y.focusin = "onfocusin" in C; var bt = /^(?:focusinfocus|focusoutblur)$/, wt = function (e) { e.stopPropagation() }; S.extend(S.event, { trigger: function (e, t, n, r) { var i, o, a, s, u, l, c, f, p = [n || E], d = v.call(e, "type") ? e.type : e, h = v.call(e, "namespace") ? e.namespace.split(".") : []; if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !bt.test(d + S.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[S.expando] ? e : new S.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : S.makeArray(t, [e]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) { if (!r && !c.noBubble && !x(n)) { for (s = c.delegateType || d, bt.test(s + d) || (o = o.parentNode); o; o = o.parentNode)p.push(o), a = o; a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C) } i = 0; while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Y.get(o, "events") || Object.create(null))[e.type] && Y.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault()); return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, wt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, wt), S.event.triggered = void 0, a && (n[u] = a)), e.result } }, simulate: function (e, t, n) { var r = S.extend(new S.Event, n, { type: e, isSimulated: !0 }); S.event.trigger(r, null, t) } }), S.fn.extend({ trigger: function (e, t) { return this.each(function () { S.event.trigger(e, t, this) }) }, triggerHandler: function (e, t) { var n = this[0]; if (n) return S.event.trigger(e, t, n, !0) } }), y.focusin || S.each({ focus: "focusin", blur: "focusout" }, function (n, r) { var i = function (e) { S.event.simulate(r, e.target, S.event.fix(e)) }; S.event.special[r] = { setup: function () { var e = this.ownerDocument || this.document || this, t = Y.access(e, r); t || e.addEventListener(n, i, !0), Y.access(e, r, (t || 0) + 1) }, teardown: function () { var e = this.ownerDocument || this.document || this, t = Y.access(e, r) - 1; t ? Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r)) } } }); var Tt = C.location, Ct = { guid: Date.now() }, Et = /\?/; S.parseXML = function (e) { var t; if (!e || "string" != typeof e) return null; try { t = (new C.DOMParser).parseFromString(e, "text/xml") } catch (e) { t = void 0 } return t && !t.getElementsByTagName("parsererror").length || S.error("Invalid XML: " + e), t }; var St = /\[\]$/, kt = /\r?\n/g, At = /^(?:submit|button|image|reset|file)$/i, Nt = /^(?:input|select|textarea|keygen)/i; function Dt(n, e, r, i) { var t; if (Array.isArray(e)) S.each(e, function (e, t) { r || St.test(n) ? i(n, t) : Dt(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i) }); else if (r || "object" !== w(e)) i(n, e); else for (t in e) Dt(n + "[" + t + "]", e[t], r, i) } S.param = function (e, t) { var n, r = [], i = function (e, t) { var n = m(t) ? t() : t; r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n) }; if (null == e) return ""; if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function () { i(this.name, this.value) }); else for (n in e) Dt(n, e[n], t, i); return r.join("&") }, S.fn.extend({ serialize: function () { return S.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var e = S.prop(this, "elements"); return e ? S.makeArray(e) : this }).filter(function () { var e = this.type; return this.name && !S(this).is(":disabled") && Nt.test(this.nodeName) && !At.test(e) && (this.checked || !pe.test(e)) }).map(function (e, t) { var n = S(this).val(); return null == n ? null : Array.isArray(n) ? S.map(n, function (e) { return { name: t.name, value: e.replace(kt, "\r\n") } }) : { name: t.name, value: n.replace(kt, "\r\n") } }).get() } }); var jt = /%20/g, qt = /#.*$/, Lt = /([?&])_=[^&]*/, Ht = /^(.*?):[ \t]*([^\r\n]*)$/gm, Ot = /^(?:GET|HEAD)$/, Pt = /^\/\//, Rt = {}, Mt = {}, It = "*/".concat("*"), Wt = E.createElement("a"); function Ft(o) { return function (e, t) { "string" != typeof e && (t = e, e = "*"); var n, r = 0, i = e.toLowerCase().match(P) || []; if (m(t)) while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t) } } function Bt(t, i, o, a) { var s = {}, u = t === Mt; function l(e) { var r; return s[e] = !0, S.each(t[e] || [], function (e, t) { var n = t(i, o, a); return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1) }), r } return l(i.dataTypes[0]) || !s["*"] && l("*") } function $t(e, t) { var n, r, i = S.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && S.extend(!0, e, r), e } Wt.href = Tt.href, S.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Tt.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": It, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": S.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? $t($t(e, S.ajaxSettings), t) : $t(S.ajaxSettings, e) }, ajaxPrefilter: Ft(Rt), ajaxTransport: Ft(Mt), ajax: function (e, t) { "object" == typeof e && (t = e, e = void 0), t = t || {}; var c, f, p, n, d, r, h, g, i, o, v = S.ajaxSetup({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event, x = S.Deferred(), b = S.Callbacks("once memory"), w = v.statusCode || {}, a = {}, s = {}, u = "canceled", T = { readyState: 0, getResponseHeader: function (e) { var t; if (h) { if (!n) { n = {}; while (t = Ht.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]) } t = n[e.toLowerCase() + " "] } return null == t ? null : t.join(", ") }, getAllResponseHeaders: function () { return h ? p : null }, setRequestHeader: function (e, t) { return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this }, overrideMimeType: function (e) { return null == h && (v.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (h) T.always(e[T.status]); else for (t in e) w[t] = [w[t], e[t]]; return this }, abort: function (e) { var t = e || u; return c && c.abort(t), l(0, t), this } }; if (x.promise(T), v.url = ((e || v.url || Tt.href) + "").replace(Pt, Tt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [""], null == v.crossDomain) { r = E.createElement("a"); try { r.href = v.url, r.href = r.href, v.crossDomain = Wt.protocol + "//" + Wt.host != r.protocol + "//" + r.host } catch (e) { v.crossDomain = !0 } } if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Bt(Rt, v, t, T), h) return T; for (i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Ot.test(v.type), f = v.url.replace(qt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(jt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Et.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Lt, "$1"), o = (Et.test(f) ? "&" : "?") + "_=" + Ct.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + It + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]); if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort(); if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Bt(Mt, v, t, T)) { if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T; v.async && 0 < v.timeout && (d = C.setTimeout(function () { T.abort("timeout") }, v.timeout)); try { h = !1, c.send(a, l) } catch (e) { if (h) throw e; l(-1, e) } } else l(-1, "No Transport"); function l(e, t, n, r) { var i, o, a, s, u, l = t; h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) { var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type")); if (r) for (i in s) if (s[i] && s[i].test(r)) { u.unshift(i); break } if (u[0] in n) o = u[0]; else { for (i in n) { if (!u[0] || e.converters[i + " " + u[0]]) { o = i; break } a || (a = i) } o = o || a } if (o) return o !== u[0] && u.unshift(o), n[o] }(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && (v.converters["text script"] = function () { }), s = function (e, t, n, r) { var i, o, a, s, u, l = {}, c = e.dataTypes.slice(); if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a]; o = c.shift(); while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u; else if ("*" !== u && u !== o) { if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) { !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break } if (!0 !== a) if (a && e["throws"]) t = a(t); else try { t = a(t) } catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + u + " to " + o } } } return { state: "success", data: t } }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --S.active || S.event.trigger("ajaxStop"))) } return T }, getJSON: function (e, t, n) { return S.get(e, t, n, "json") }, getScript: function (e, t) { return S.get(e, void 0, t, "script") } }), S.each(["get", "post"], function (e, i) { S[i] = function (e, t, n, r) { return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({ url: e, type: i, dataType: r, data: t, success: n }, S.isPlainObject(e) && e)) } }), S.ajaxPrefilter(function (e) { var t; for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "") }), S._evalUrl = function (e, t, n) { return S.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function () { } }, dataFilter: function (e) { S.globalEval(e, t, n) } }) }, S.fn.extend({ wrapAll: function (e) { var t; return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e }).append(this)), this }, wrapInner: function (n) { return m(n) ? this.each(function (e) { S(this).wrapInner(n.call(this, e)) }) : this.each(function () { var e = S(this), t = e.contents(); t.length ? t.wrapAll(n) : e.append(n) }) }, wrap: function (t) { var n = m(t); return this.each(function (e) { S(this).wrapAll(n ? t.call(this, e) : t) }) }, unwrap: function (e) { return this.parent(e).not("body").each(function () { S(this).replaceWith(this.childNodes) }), this } }), S.expr.pseudos.hidden = function (e) { return !S.expr.pseudos.visible(e) }, S.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, S.ajaxSettings.xhr = function () { try { return new C.XMLHttpRequest } catch (e) { } }; var _t = { 0: 200, 1223: 204 }, zt = S.ajaxSettings.xhr(); y.cors = !!zt && "withCredentials" in zt, y.ajax = zt = !!zt, S.ajaxTransport(function (i) { var o, a; if (y.cors || zt && !i.crossDomain) return { send: function (e, t) { var n, r = i.xhr(); if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for (n in i.xhrFields) r[n] = i.xhrFields[n]; for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]); o = function (e) { return function () { o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(_t[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? { binary: r.response } : { text: r.responseText }, r.getAllResponseHeaders())) } }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () { 4 === r.readyState && C.setTimeout(function () { o && a() }) }, o = o("abort"); try { r.send(i.hasContent && i.data || null) } catch (e) { if (o) throw e } }, abort: function () { o && o() } } }), S.ajaxPrefilter(function (e) { e.crossDomain && (e.contents.script = !1) }), S.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (e) { return S.globalEval(e), e } } }), S.ajaxPrefilter("script", function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") }), S.ajaxTransport("script", function (n) { var r, i; if (n.crossDomain || n.scriptAttrs) return { send: function (e, t) { r = S("<script>").attr(n.scriptAttrs || {}).prop({ charset: n.scriptCharset, src: n.url }).on("load error", i = function (e) { r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type) }), E.head.appendChild(r[0]) }, abort: function () { i && i() } } }); var Ut, Xt = [], Vt = /(=)\?(?=&|$)|\?\?/; S.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = Xt.pop() || S.expando + "_" + Ct.guid++; return this[e] = !0, e } }), S.ajaxPrefilter("json jsonp", function (e, t, n) { var r, i, o, a = !1 !== e.jsonp && (Vt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Vt.test(e.data) && "data"); if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Vt, "$1" + r) : !1 !== e.jsonp && (e.url += (Et.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () { return o || S.error(r + " was not called"), o[0] }, e.dataTypes[0] = "json", i = C[r], C[r] = function () { o = arguments }, n.always(function () { void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, Xt.push(r)), o && m(i) && i(o[0]), o = i = void 0 }), "script" }), y.createHTMLDocument = ((Ut = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Ut.childNodes.length), S.parseHTML = function (e, t, n) { return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes))); var r, i, o }, S.fn.load = function (e, t, n) { var r, i, o, a = this, s = e.indexOf(" "); return -1 < s && (r = vt(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && S.ajax({ url: e, type: i || "GET", dataType: "html", data: t }).done(function (e) { o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e) }).always(n && function (e, t) { a.each(function () { n.apply(this, o || [e.responseText, t, e]) }) }), this }, S.expr.pseudos.animated = function (t) { return S.grep(S.timers, function (e) { return t === e.elem }).length }, S.offset = { setOffset: function (e, t, n) { var r, i, o, a, s, u, l = S.css(e, "position"), c = S(e), f = {}; "static" === l && (e.style.position = "relative"), s = c.offset(), o = S.css(e, "top"), u = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : ("number" == typeof f.top && (f.top += "px"), "number" == typeof f.left && (f.left += "px"), c.css(f)) } }, S.fn.extend({ offset: function (t) { if (arguments.length) return void 0 === t ? this : this.each(function (e) { S.offset.setOffset(this, t, e) }); var e, n, r = this[0]; return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: e.top + n.pageYOffset, left: e.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0 }, position: function () { if (this[0]) { var e, t, n, r = this[0], i = { top: 0, left: 0 }; if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect(); else { t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position")) e = e.parentNode; e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0)) } return { top: t.top - i.top - S.css(r, "marginTop", !0), left: t.left - i.left - S.css(r, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var e = this.offsetParent; while (e && "static" === S.css(e, "position")) e = e.offsetParent; return e || re }) } }), S.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (t, i) { var o = "pageYOffset" === i; S.fn[t] = function (e) { return $(this, function (e, t, n) { var r; if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t]; r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n }, t, e, arguments.length) } }), S.each(["top", "left"], function (e, n) { S.cssHooks[n] = $e(y.pixelPosition, function (e, t) { if (t) return t = Be(e, n), Me.test(t) ? S(e).position()[n] + "px" : t }) }), S.each({ Height: "height", Width: "width" }, function (a, s) { S.each({ padding: "inner" + a, content: s, "": "outer" + a }, function (r, o) { S.fn[o] = function (e, t) { var n = arguments.length && (r || "boolean" != typeof e), i = r || (!0 === e || !0 === t ? "margin" : "border"); return $(this, function (e, t, n) { var r; return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i) }, s, n ? e : void 0, n) } }) }), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) { S.fn[t] = function (e) { return this.on(t, e) } }), S.fn.extend({ bind: function (e, t, n) { return this.on(e, null, t, n) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function (e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) }, hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e) } }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, n) { S.fn[n] = function (e, t) { return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n) } }); var Gt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; S.proxy = function (e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function () { return e.apply(t || this, r.concat(s.call(arguments))) }).guid = e.guid = e.guid || S.guid++, i }, S.holdReady = function (e) { e ? S.readyWait++ : S.ready(!0) }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) { var t = S.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, S.trim = function (e) { return null == e ? "" : (e + "").replace(Gt, "") }, "function" == typeof define && define.amd && define("jquery", [], function () { return S }); var Yt = C.jQuery, Qt = C.$; return S.noConflict = function (e) { return C.$ === S && (C.$ = Qt), e && C.jQuery === S && (C.jQuery = Yt), S }, "undefined" == typeof e && (C.jQuery = C.$ = S), S });

	</script>

	<script>
		(function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({
			1: [function (require, module, exports) {
				/*
				 * Generated by PEG.js 0.10.0.
				 *
				 * http://pegjs.org/
				 */

				"use strict";

				function peg$subclass(child, parent) {
					function ctor() { this.constructor = child; }
					ctor.prototype = parent.prototype;
					child.prototype = new ctor();
				}

				function peg$SyntaxError(message, expected, found, location) {
					this.message = message;
					this.expected = expected;
					this.found = found;
					this.location = location;
					this.name = "SyntaxError";

					if (typeof Error.captureStackTrace === "function") {
						Error.captureStackTrace(this, peg$SyntaxError);
					}
				}

				peg$subclass(peg$SyntaxError, Error);

				peg$SyntaxError.buildMessage = function (expected, found) {
					var DESCRIBE_EXPECTATION_FNS = {
						literal: function (expectation) {
							return "\"" + literalEscape(expectation.text) + "\"";
						},

						"class": function (expectation) {
							var escapedParts = "",
								i;

							for (i = 0; i < expectation.parts.length; i++) {
								escapedParts += expectation.parts[i] instanceof Array
									? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
									: classEscape(expectation.parts[i]);
							}

							return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
						},

						any: function (expectation) {
							return "any character";
						},

						end: function (expectation) {
							return "end of input";
						},

						other: function (expectation) {
							return expectation.description;
						}
					};

					function hex(ch) {
						return ch.charCodeAt(0).toString(16).toUpperCase();
					}

					function literalEscape(s) {
						return s
							.replace(/\\/g, '\\\\')
							.replace(/"/g, '\\"')
							.replace(/\0/g, '\\0')
							.replace(/\t/g, '\\t')
							.replace(/\n/g, '\\n')
							.replace(/\r/g, '\\r')
							.replace(/[\x00-\x0F]/g, function (ch) { return '\\x0' + hex(ch); })
							.replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return '\\x' + hex(ch); });
					}

					function classEscape(s) {
						return s
							.replace(/\\/g, '\\\\')
							.replace(/\]/g, '\\]')
							.replace(/\^/g, '\\^')
							.replace(/-/g, '\\-')
							.replace(/\0/g, '\\0')
							.replace(/\t/g, '\\t')
							.replace(/\n/g, '\\n')
							.replace(/\r/g, '\\r')
							.replace(/[\x00-\x0F]/g, function (ch) { return '\\x0' + hex(ch); })
							.replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return '\\x' + hex(ch); });
					}

					function describeExpectation(expectation) {
						return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
					}

					function describeExpected(expected) {
						var descriptions = new Array(expected.length),
							i, j;

						for (i = 0; i < expected.length; i++) {
							descriptions[i] = describeExpectation(expected[i]);
						}

						descriptions.sort();

						if (descriptions.length > 0) {
							for (i = 1, j = 1; i < descriptions.length; i++) {
								if (descriptions[i - 1] !== descriptions[i]) {
									descriptions[j] = descriptions[i];
									j++;
								}
							}
							descriptions.length = j;
						}

						switch (descriptions.length) {
							case 1:
								return descriptions[0];

							case 2:
								return descriptions[0] + " or " + descriptions[1];

							default:
								return descriptions.slice(0, -1).join(", ")
									+ ", or "
									+ descriptions[descriptions.length - 1];
						}
					}

					function describeFound(found) {
						return found ? "\"" + literalEscape(found) + "\"" : "end of input";
					}

					return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
				};

				function peg$parse(input, options) {
					options = options !== void 0 ? options : {};

					var peg$FAILED = {},

						peg$startRuleFunctions = { pgn: peg$parsepgn, tags: peg$parsetags, game: peg$parsegame, games: peg$parsegames },
						peg$startRuleFunction = peg$parsepgn,

						peg$c0 = function (head, m) { return m; },
						peg$c1 = function (head, tail) { return [head].concat(tail) },
						peg$c2 = function (games) { return games },
						peg$c3 = function (t, p) { return { tags: t, moves: p[0] }; },
						peg$c4 = function (head, tail) {
							var result = {};
							[head].concat(tail).forEach(function (element) {
								result[element.name] = element.value;
							});
							return result;
						},
						peg$c5 = function (members) { return members !== null ? members : {}; },
						peg$c6 = function (tag) { return tag; },
						peg$c7 = function (value) { return { name: 'Event', value: value }; },
						peg$c8 = function (value) { return { name: 'Site', value: value }; },
						peg$c9 = function (value) { return { name: 'Date', value: value }; },
						peg$c10 = function (value) { return { name: 'Round', value: value }; },
						peg$c11 = function (value) { return { name: 'WhiteTitle', value: value }; },
						peg$c12 = function (value) { return { name: 'BlackTitle', value: value }; },
						peg$c13 = function (value) { return { name: 'WhiteELO', value: value }; },
						peg$c14 = function (value) { return { name: 'BlackELO', value: value }; },
						peg$c15 = function (value) { return { name: 'WhiteUSCF', value: value }; },
						peg$c16 = function (value) { return { name: 'BlackUSCF', value: value }; },
						peg$c17 = function (value) { return { name: 'WhiteNA', value: value }; },
						peg$c18 = function (value) { return { name: 'BlackNA', value: value }; },
						peg$c19 = function (value) { return { name: 'WhiteType', value: value }; },
						peg$c20 = function (value) { return { name: 'BlackType', value: value }; },
						peg$c21 = function (value) { return { name: 'White', value: value }; },
						peg$c22 = function (value) { return { name: 'Black', value: value }; },
						peg$c23 = function (value) { return { name: 'Result', value: value }; },
						peg$c24 = function (value) { return { name: 'EventDate', value: value }; },
						peg$c25 = function (value) { return { name: 'EventSponsor', value: value }; },
						peg$c26 = function (value) { return { name: 'Section', value: value }; },
						peg$c27 = function (value) { return { name: 'Stage', value: value }; },
						peg$c28 = function (value) { return { name: 'Board', value: value }; },
						peg$c29 = function (value) { return { name: 'Opening', value: value }; },
						peg$c30 = function (value) { return { name: 'Variation', value: value }; },
						peg$c31 = function (value) { return { name: 'SubVariation', value: value }; },
						peg$c32 = function (value) { return { name: 'ECO', value: value }; },
						peg$c33 = function (value) { return { name: 'NIC', value: value }; },
						peg$c34 = function (value) { return { name: 'Time', value: value }; },
						peg$c35 = function (value) { return { name: 'UTCTime', value: value }; },
						peg$c36 = function (value) { return { name: 'UTCDate', value: value }; },
						peg$c37 = function (value) { return { name: 'TimeControl', value: value }; },
						peg$c38 = function (value) { return { name: 'SetUp', value: value }; },
						peg$c39 = function (value) { return { name: 'FEN', value: value }; },
						peg$c40 = function (value) { return { name: 'Termination', value: value }; },
						peg$c41 = function (value) { return { name: 'Annotator', value: value }; },
						peg$c42 = function (value) { return { name: 'Mode', value: value }; },
						peg$c43 = function (value) { return { name: 'PlyCount', value: value }; },
						peg$c44 = function (any, value) { return { name: any, value: value }; },
						peg$c45 = "Event",
						peg$c46 = peg$literalExpectation("Event", false),
						peg$c47 = "event",
						peg$c48 = peg$literalExpectation("event", false),
						peg$c49 = "Site",
						peg$c50 = peg$literalExpectation("Site", false),
						peg$c51 = "site",
						peg$c52 = peg$literalExpectation("site", false),
						peg$c53 = "Date",
						peg$c54 = peg$literalExpectation("Date", false),
						peg$c55 = "date",
						peg$c56 = peg$literalExpectation("date", false),
						peg$c57 = "Round",
						peg$c58 = peg$literalExpectation("Round", false),
						peg$c59 = "round",
						peg$c60 = peg$literalExpectation("round", false),
						peg$c61 = "White",
						peg$c62 = peg$literalExpectation("White", false),
						peg$c63 = "Black",
						peg$c64 = peg$literalExpectation("Black", false),
						peg$c65 = "black",
						peg$c66 = peg$literalExpectation("black", false),
						peg$c67 = "Result",
						peg$c68 = peg$literalExpectation("Result", false),
						peg$c69 = "result",
						peg$c70 = peg$literalExpectation("result", false),
						peg$c71 = "WhiteTitle",
						peg$c72 = peg$literalExpectation("WhiteTitle", false),
						peg$c73 = "Whitetitle",
						peg$c74 = peg$literalExpectation("Whitetitle", false),
						peg$c75 = "whitetitle",
						peg$c76 = peg$literalExpectation("whitetitle", false),
						peg$c77 = "BlackTitle",
						peg$c78 = peg$literalExpectation("BlackTitle", false),
						peg$c79 = "Blacktitle",
						peg$c80 = peg$literalExpectation("Blacktitle", false),
						peg$c81 = "blacktitle",
						peg$c82 = peg$literalExpectation("blacktitle", false),
						peg$c83 = "WhiteELO",
						peg$c84 = peg$literalExpectation("WhiteELO", false),
						peg$c85 = "WhiteElo",
						peg$c86 = peg$literalExpectation("WhiteElo", false),
						peg$c87 = "Whiteelo",
						peg$c88 = peg$literalExpectation("Whiteelo", false),
						peg$c89 = "whiteelo",
						peg$c90 = peg$literalExpectation("whiteelo", false),
						peg$c91 = "BlackELO",
						peg$c92 = peg$literalExpectation("BlackELO", false),
						peg$c93 = "BlackElo",
						peg$c94 = peg$literalExpectation("BlackElo", false),
						peg$c95 = "Blackelo",
						peg$c96 = peg$literalExpectation("Blackelo", false),
						peg$c97 = "blackelo",
						peg$c98 = peg$literalExpectation("blackelo", false),
						peg$c99 = "WhiteUSCF",
						peg$c100 = peg$literalExpectation("WhiteUSCF", false),
						peg$c101 = "WhiteUscf",
						peg$c102 = peg$literalExpectation("WhiteUscf", false),
						peg$c103 = "Whiteuscf",
						peg$c104 = peg$literalExpectation("Whiteuscf", false),
						peg$c105 = "whiteuscf",
						peg$c106 = peg$literalExpectation("whiteuscf", false),
						peg$c107 = "BlackUSCF",
						peg$c108 = peg$literalExpectation("BlackUSCF", false),
						peg$c109 = "BlackUscf",
						peg$c110 = peg$literalExpectation("BlackUscf", false),
						peg$c111 = "Blackuscf",
						peg$c112 = peg$literalExpectation("Blackuscf", false),
						peg$c113 = "blackuscf",
						peg$c114 = peg$literalExpectation("blackuscf", false),
						peg$c115 = "WhiteNA",
						peg$c116 = peg$literalExpectation("WhiteNA", false),
						peg$c117 = "WhiteNa",
						peg$c118 = peg$literalExpectation("WhiteNa", false),
						peg$c119 = "Whitena",
						peg$c120 = peg$literalExpectation("Whitena", false),
						peg$c121 = "whitena",
						peg$c122 = peg$literalExpectation("whitena", false),
						peg$c123 = "BlackNA",
						peg$c124 = peg$literalExpectation("BlackNA", false),
						peg$c125 = "BlackNa",
						peg$c126 = peg$literalExpectation("BlackNa", false),
						peg$c127 = "Blackna",
						peg$c128 = peg$literalExpectation("Blackna", false),
						peg$c129 = "blackna",
						peg$c130 = peg$literalExpectation("blackna", false),
						peg$c131 = "WhiteType",
						peg$c132 = peg$literalExpectation("WhiteType", false),
						peg$c133 = "Whitetype",
						peg$c134 = peg$literalExpectation("Whitetype", false),
						peg$c135 = "whitetype",
						peg$c136 = peg$literalExpectation("whitetype", false),
						peg$c137 = "BlackType",
						peg$c138 = peg$literalExpectation("BlackType", false),
						peg$c139 = "Blacktype",
						peg$c140 = peg$literalExpectation("Blacktype", false),
						peg$c141 = "blacktype",
						peg$c142 = peg$literalExpectation("blacktype", false),
						peg$c143 = "EventDate",
						peg$c144 = peg$literalExpectation("EventDate", false),
						peg$c145 = "Eventdate",
						peg$c146 = peg$literalExpectation("Eventdate", false),
						peg$c147 = "eventdate",
						peg$c148 = peg$literalExpectation("eventdate", false),
						peg$c149 = "EventSponsor",
						peg$c150 = peg$literalExpectation("EventSponsor", false),
						peg$c151 = "Eventsponsor",
						peg$c152 = peg$literalExpectation("Eventsponsor", false),
						peg$c153 = "eventsponsor",
						peg$c154 = peg$literalExpectation("eventsponsor", false),
						peg$c155 = "Section",
						peg$c156 = peg$literalExpectation("Section", false),
						peg$c157 = "section",
						peg$c158 = peg$literalExpectation("section", false),
						peg$c159 = "Stage",
						peg$c160 = peg$literalExpectation("Stage", false),
						peg$c161 = "stage",
						peg$c162 = peg$literalExpectation("stage", false),
						peg$c163 = "Board",
						peg$c164 = peg$literalExpectation("Board", false),
						peg$c165 = "board",
						peg$c166 = peg$literalExpectation("board", false),
						peg$c167 = "Opening",
						peg$c168 = peg$literalExpectation("Opening", false),
						peg$c169 = "opening",
						peg$c170 = peg$literalExpectation("opening", false),
						peg$c171 = "Variation",
						peg$c172 = peg$literalExpectation("Variation", false),
						peg$c173 = "variation",
						peg$c174 = peg$literalExpectation("variation", false),
						peg$c175 = "SubVariation",
						peg$c176 = peg$literalExpectation("SubVariation", false),
						peg$c177 = "Subvariation",
						peg$c178 = peg$literalExpectation("Subvariation", false),
						peg$c179 = "subvariation",
						peg$c180 = peg$literalExpectation("subvariation", false),
						peg$c181 = "ECO",
						peg$c182 = peg$literalExpectation("ECO", false),
						peg$c183 = "Eco",
						peg$c184 = peg$literalExpectation("Eco", false),
						peg$c185 = "eco",
						peg$c186 = peg$literalExpectation("eco", false),
						peg$c187 = "NIC",
						peg$c188 = peg$literalExpectation("NIC", false),
						peg$c189 = "Nic",
						peg$c190 = peg$literalExpectation("Nic", false),
						peg$c191 = "nic",
						peg$c192 = peg$literalExpectation("nic", false),
						peg$c193 = "Time",
						peg$c194 = peg$literalExpectation("Time", false),
						peg$c195 = "time",
						peg$c196 = peg$literalExpectation("time", false),
						peg$c197 = "UTCTime",
						peg$c198 = peg$literalExpectation("UTCTime", false),
						peg$c199 = "UTCtime",
						peg$c200 = peg$literalExpectation("UTCtime", false),
						peg$c201 = "UtcTime",
						peg$c202 = peg$literalExpectation("UtcTime", false),
						peg$c203 = "Utctime",
						peg$c204 = peg$literalExpectation("Utctime", false),
						peg$c205 = "utctime",
						peg$c206 = peg$literalExpectation("utctime", false),
						peg$c207 = "UTCDate",
						peg$c208 = peg$literalExpectation("UTCDate", false),
						peg$c209 = "UTCdate",
						peg$c210 = peg$literalExpectation("UTCdate", false),
						peg$c211 = "UtcDate",
						peg$c212 = peg$literalExpectation("UtcDate", false),
						peg$c213 = "Utcdate",
						peg$c214 = peg$literalExpectation("Utcdate", false),
						peg$c215 = "utcdate",
						peg$c216 = peg$literalExpectation("utcdate", false),
						peg$c217 = "TimeControl",
						peg$c218 = peg$literalExpectation("TimeControl", false),
						peg$c219 = "Timecontrol",
						peg$c220 = peg$literalExpectation("Timecontrol", false),
						peg$c221 = "timecontrol",
						peg$c222 = peg$literalExpectation("timecontrol", false),
						peg$c223 = "SetUp",
						peg$c224 = peg$literalExpectation("SetUp", false),
						peg$c225 = "Setup",
						peg$c226 = peg$literalExpectation("Setup", false),
						peg$c227 = "setup",
						peg$c228 = peg$literalExpectation("setup", false),
						peg$c229 = "FEN",
						peg$c230 = peg$literalExpectation("FEN", false),
						peg$c231 = "Fen",
						peg$c232 = peg$literalExpectation("Fen", false),
						peg$c233 = "fen",
						peg$c234 = peg$literalExpectation("fen", false),
						peg$c235 = "Termination",
						peg$c236 = peg$literalExpectation("Termination", false),
						peg$c237 = "termination",
						peg$c238 = peg$literalExpectation("termination", false),
						peg$c239 = "Annotator",
						peg$c240 = peg$literalExpectation("Annotator", false),
						peg$c241 = "annotator",
						peg$c242 = peg$literalExpectation("annotator", false),
						peg$c243 = "Mode",
						peg$c244 = peg$literalExpectation("Mode", false),
						peg$c245 = "mode",
						peg$c246 = peg$literalExpectation("mode", false),
						peg$c247 = "PlyCount",
						peg$c248 = peg$literalExpectation("PlyCount", false),
						peg$c249 = "Plycount",
						peg$c250 = peg$literalExpectation("Plycount", false),
						peg$c251 = "plycount",
						peg$c252 = peg$literalExpectation("plycount", false),
						peg$c253 = peg$otherExpectation("whitespace"),
						peg$c254 = /^[ \t\n\r]/,
						peg$c255 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),
						peg$c256 = /^[\n\r]/,
						peg$c257 = peg$classExpectation(["\n", "\r"], false, false),
						peg$c258 = peg$otherExpectation("string"),
						peg$c259 = function (chars) { return chars.join(""); },
						peg$c260 = /^[a-zA-Z0-9]/,
						peg$c261 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
						peg$c262 = "\"",
						peg$c263 = peg$literalExpectation("\"", false),
						peg$c264 = /^[^\0-\x1F"\\]/,
						peg$c265 = peg$classExpectation([["\0", "\x1F"], "\"", "\\"], true, false),
						peg$c266 = /^[0-9?]/,
						peg$c267 = peg$classExpectation([["0", "9"], "?"], false, false),
						peg$c268 = ".",
						peg$c269 = peg$literalExpectation(".", false),
						peg$c270 = function (year, month, day) { return "" + year.join("") + '.' + month.join("") + '.' + day.join(""); },
						peg$c271 = function (res) { return res; },
						peg$c272 = "1-0",
						peg$c273 = peg$literalExpectation("1-0", false),
						peg$c274 = function (res) { return res; },
						peg$c275 = "1:0",
						peg$c276 = peg$literalExpectation("1:0", false),
						peg$c277 = "0-1",
						peg$c278 = peg$literalExpectation("0-1", false),
						peg$c279 = "0:1",
						peg$c280 = peg$literalExpectation("0:1", false),
						peg$c281 = "1/2-1/2",
						peg$c282 = peg$literalExpectation("1/2-1/2", false),
						peg$c283 = "*",
						peg$c284 = peg$literalExpectation("*", false),
						peg$c285 = "-",
						peg$c286 = peg$literalExpectation("-", false),
						peg$c287 = /^[0-9]/,
						peg$c288 = peg$classExpectation([["0", "9"]], false, false),
						peg$c289 = function (digits) { return makeInteger(digits); },
						peg$c290 = function (pw, all) { var arr = (all ? all : []); arr.unshift(pw); return arr; },
						peg$c291 = function (pb, all) { var arr = (all ? all : []); arr.unshift(pb); return arr; },
						peg$c292 = function () { return [[]]; },
						peg$c293 = function (pw) { return pw; },
						peg$c294 = function (pb) { return pb; },
						peg$c295 = function (cm, mn, cb, hm, nag, ca, cd, vari, all) {
							var arr = (all ? all : []);
							var move = {}; move.turn = 'w'; move.moveNumber = mn;
							move.notation = hm; move.commentBefore = cb; move.commentAfter = ca; move.commentMove = cm;
							move.variations = (vari ? vari : []); move.nag = (nag ? nag : null); arr.unshift(move);
							move.commentDiag = cd;
							if (cd && cd.text) { move.commentAfter = [move.commentAfter, cd.text].join(' '); }
							return arr;
						},
						peg$c296 = function (cm, me, cb, hm, nag, ca, cd, vari, all) {
							var arr = (all ? all : []);
							var move = {}; move.turn = 'b'; move.moveNumber = me;
							move.notation = hm; move.commentBefore = cb; move.commentAfter = ca; move.commentMove = cm;
							move.variations = (vari ? vari : []); arr.unshift(move); move.nag = (nag ? nag : null);
							move.commentDiag = cd;
							if (cd && cd.text) { move.commentAfter = [move.commentAfter, cd.text].join(' ').trim(); }
							return arr;
						},
						peg$c297 = function () { return ["1:0"]; },
						peg$c298 = function () { return ["0:1"]; },
						peg$c299 = function () { return ["1-0"]; },
						peg$c300 = function () { return ["0-1"]; },
						peg$c301 = function () { return ["1/2-1/2"]; },
						peg$c302 = function () { return ["*"]; },
						peg$c303 = function (cf, cfl) { var comm = cf; for (var i = 0; i < cfl.length; i++) { comm += " " + cfl[i][1] }; return comm; },
						peg$c304 = function (cm) { return cm; },
						peg$c305 = /^[^\n\r]/,
						peg$c306 = peg$classExpectation(["\n", "\r"], true, false),
						peg$c307 = function (cm) { return cm.join(""); },
						peg$c308 = /^[^}]/,
						peg$c309 = peg$classExpectation(["}"], true, false),
						peg$c310 = function (cas, cm) { return { ...cas, text: cm }; },
						peg$c311 = function (ca, cal) { var ret = {}; if (cal) { var o = cal[0]; return { ...ca, ...o }; } return ca; },
						peg$c312 = function (caf) { var ret = {}; ret.colorFields = caf; return ret; },
						peg$c313 = function (caa) { var ret = {}; ret.colorArrows = caa; return ret; },
						peg$c314 = function (cac) { var ret = {}; ret.clock = cac; return ret; },
						peg$c315 = "%csl",
						peg$c316 = peg$literalExpectation("%csl", false),
						peg$c317 = function (cfs) { return cfs; },
						peg$c318 = "%cal",
						peg$c319 = peg$literalExpectation("%cal", false),
						peg$c320 = ",",
						peg$c321 = peg$literalExpectation(",", false),
						peg$c322 = function (cf, cfl) { var arr = []; arr.push(cf); for (var i = 0; i < cfl.length; i++) { arr.push(cfl[i][2]) }; return arr; },
						peg$c323 = function (col, f) { return col + f; },
						peg$c324 = function (col, ff, ft) { return col + ff + ft; },
						peg$c325 = "Y",
						peg$c326 = peg$literalExpectation("Y", false),
						peg$c327 = function () { return "Y"; },
						peg$c328 = "G",
						peg$c329 = peg$literalExpectation("G", false),
						peg$c330 = function () { return "G"; },
						peg$c331 = "R",
						peg$c332 = peg$literalExpectation("R", false),
						peg$c333 = function () { return "R"; },
						peg$c334 = "B",
						peg$c335 = peg$literalExpectation("B", false),
						peg$c336 = function () { return "B"; },
						peg$c337 = function (col, row) { return col + row; },
						peg$c338 = "{",
						peg$c339 = peg$literalExpectation("{", false),
						peg$c340 = "}",
						peg$c341 = peg$literalExpectation("}", false),
						peg$c342 = "[",
						peg$c343 = peg$literalExpectation("[", false),
						peg$c344 = "]",
						peg$c345 = peg$literalExpectation("]", false),
						peg$c346 = ";",
						peg$c347 = peg$literalExpectation(";", false),
						peg$c348 = "%",
						peg$c349 = peg$literalExpectation("%", false),
						peg$c350 = function (cc, cv) { var ret = {}; ret.type = cc; ret.value = cv; return ret; },
						peg$c351 = "clk",
						peg$c352 = peg$literalExpectation("clk", false),
						peg$c353 = function () { return "clk"; },
						peg$c354 = "egt",
						peg$c355 = peg$literalExpectation("egt", false),
						peg$c356 = function () { return "egt"; },
						peg$c357 = "emt",
						peg$c358 = peg$literalExpectation("emt", false),
						peg$c359 = function () { return "emt"; },
						peg$c360 = "mct",
						peg$c361 = peg$literalExpectation("mct", false),
						peg$c362 = function () { return "mct"; },
						peg$c363 = ":",
						peg$c364 = peg$literalExpectation(":", false),
						peg$c365 = function (h1, h2, m1, m2, s1, s2) { var ret = h1; if (h2) { ret += h2 }; ret += ":" + m1 + m2 + ":" + s1 + s2; return ret; },
						peg$c366 = function (d) { return d; },
						peg$c367 = function (vari, all) { var arr = (all ? all : []); arr.unshift(vari); return arr; },
						peg$c368 = "(",
						peg$c369 = peg$literalExpectation("(", false),
						peg$c370 = ")",
						peg$c371 = peg$literalExpectation(")", false),
						peg$c372 = function (num) { return num; },
						peg$c373 = peg$otherExpectation("integer"),
						peg$c374 = " ",
						peg$c375 = peg$literalExpectation(" ", false),
						peg$c376 = function () { return ''; },
						peg$c377 = function (fig, disc, str, col, row, pr, ch) { var hm = {}; hm.fig = (fig ? fig : null); hm.disc = (disc ? disc : null); hm.strike = (str ? str : null); hm.col = col; hm.row = row; hm.check = (ch ? ch : null); hm.promotion = pr; hm.notation = (fig ? fig : "") + (disc ? disc : "") + (str ? str : "") + col + row + (pr ? pr : "") + (ch ? ch : ""); return hm; },
						peg$c378 = function (fig, cols, rows, str, col, row, pr, ch) { var hm = {}; hm.fig = (fig ? fig : null); hm.strike = (str == 'x' ? str : null); hm.col = col; hm.row = row; hm.check = (ch ? ch : null); hm.notation = (fig && (fig !== 'P') ? fig : "") + cols + rows + (str == 'x' ? str : "-") + col + row + (pr ? pr : "") + (ch ? ch : ""); hm.promotion = pr; return hm; },
						peg$c379 = function (fig, str, col, row, pr, ch) { var hm = {}; hm.fig = (fig ? fig : null); hm.strike = (str ? str : null); hm.col = col; hm.row = row; hm.check = (ch ? ch : null); hm.notation = (fig ? fig : "") + (str ? str : "") + col + row + (pr ? pr : "") + (ch ? ch : ""); hm.promotion = pr; return hm; },
						peg$c380 = "O-O-O",
						peg$c381 = peg$literalExpectation("O-O-O", false),
						peg$c382 = function (ch) { var hm = {}; hm.notation = 'O-O-O' + (ch ? ch : ""); hm.check = (ch ? ch : null); return hm; },
						peg$c383 = "O-O",
						peg$c384 = peg$literalExpectation("O-O", false),
						peg$c385 = function (ch) { var hm = {}; hm.notation = 'O-O' + (ch ? ch : ""); hm.check = (ch ? ch : null); return hm; },
						peg$c386 = "+-",
						peg$c387 = peg$literalExpectation("+-", false),
						peg$c388 = "+",
						peg$c389 = peg$literalExpectation("+", false),
						peg$c390 = function (ch) { return ch[1]; },
						peg$c391 = "$$$",
						peg$c392 = peg$literalExpectation("$$$", false),
						peg$c393 = "#",
						peg$c394 = peg$literalExpectation("#", false),
						peg$c395 = "=",
						peg$c396 = peg$literalExpectation("=", false),
						peg$c397 = function (f) { return '=' + f; },
						peg$c398 = function (nag, nags) { var arr = (nags ? nags : []); arr.unshift(nag); return arr; },
						peg$c399 = "$",
						peg$c400 = peg$literalExpectation("$", false),
						peg$c401 = function (num) { return '$' + num; },
						peg$c402 = "!!",
						peg$c403 = peg$literalExpectation("!!", false),
						peg$c404 = function () { return '$3'; },
						peg$c405 = "??",
						peg$c406 = peg$literalExpectation("??", false),
						peg$c407 = function () { return '$4'; },
						peg$c408 = "!?",
						peg$c409 = peg$literalExpectation("!?", false),
						peg$c410 = function () { return '$5'; },
						peg$c411 = "?!",
						peg$c412 = peg$literalExpectation("?!", false),
						peg$c413 = function () { return '$6'; },
						peg$c414 = "!",
						peg$c415 = peg$literalExpectation("!", false),
						peg$c416 = function () { return '$1'; },
						peg$c417 = "?",
						peg$c418 = peg$literalExpectation("?", false),
						peg$c419 = function () { return '$2'; },
						peg$c420 = "\u203C",
						peg$c421 = peg$literalExpectation("\u203C", false),
						peg$c422 = "\u2047",
						peg$c423 = peg$literalExpectation("\u2047", false),
						peg$c424 = "\u2049",
						peg$c425 = peg$literalExpectation("\u2049", false),
						peg$c426 = "\u2048",
						peg$c427 = peg$literalExpectation("\u2048", false),
						peg$c428 = "\u25A1",
						peg$c429 = peg$literalExpectation("\u25A1", false),
						peg$c430 = function () { return '$7'; },
						peg$c431 = function () { return '$10'; },
						peg$c432 = "\u221E",
						peg$c433 = peg$literalExpectation("\u221E", false),
						peg$c434 = function () { return '$13'; },
						peg$c435 = "\u2A72",
						peg$c436 = peg$literalExpectation("\u2A72", false),
						peg$c437 = function () { return '$14'; },
						peg$c438 = "\u2A71",
						peg$c439 = peg$literalExpectation("\u2A71", false),
						peg$c440 = function () { return '$15'; },
						peg$c441 = "\xB1",
						peg$c442 = peg$literalExpectation("\xB1", false),
						peg$c443 = function () { return '$16'; },
						peg$c444 = "\u2213",
						peg$c445 = peg$literalExpectation("\u2213", false),
						peg$c446 = function () { return '$17'; },
						peg$c447 = function () { return '$18'; },
						peg$c448 = "-+",
						peg$c449 = peg$literalExpectation("-+", false),
						peg$c450 = function () { return '$19'; },
						peg$c451 = "\u2A00",
						peg$c452 = peg$literalExpectation("\u2A00", false),
						peg$c453 = function () { return '$22'; },
						peg$c454 = "\u27F3",
						peg$c455 = peg$literalExpectation("\u27F3", false),
						peg$c456 = function () { return '$32'; },
						peg$c457 = "\u2192",
						peg$c458 = peg$literalExpectation("\u2192", false),
						peg$c459 = function () { return '$36'; },
						peg$c460 = "\u2191",
						peg$c461 = peg$literalExpectation("\u2191", false),
						peg$c462 = function () { return '$40'; },
						peg$c463 = "\u21C6",
						peg$c464 = peg$literalExpectation("\u21C6", false),
						peg$c465 = function () { return '$132'; },
						peg$c466 = "D",
						peg$c467 = peg$literalExpectation("D", false),
						peg$c468 = function () { return '$220'; },
						peg$c469 = /^[RNBQKP]/,
						peg$c470 = peg$classExpectation(["R", "N", "B", "Q", "K", "P"], false, false),
						peg$c471 = /^[RNBQ]/,
						peg$c472 = peg$classExpectation(["R", "N", "B", "Q"], false, false),
						peg$c473 = /^[a-h]/,
						peg$c474 = peg$classExpectation([["a", "h"]], false, false),
						peg$c475 = /^[1-8]/,
						peg$c476 = peg$classExpectation([["1", "8"]], false, false),
						peg$c477 = "x",
						peg$c478 = peg$literalExpectation("x", false),

						peg$currPos = 0,
						peg$savedPos = 0,
						peg$posDetailsCache = [{ line: 1, column: 1 }],
						peg$maxFailPos = 0,
						peg$maxFailExpected = [],
						peg$silentFails = 0,

						peg$result;

					if ("startRule" in options) {
						if (!(options.startRule in peg$startRuleFunctions)) {
							throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
						}

						peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
					}

					function text() {
						return input.substring(peg$savedPos, peg$currPos);
					}

					function location() {
						return peg$computeLocation(peg$savedPos, peg$currPos);
					}

					function expected(description, location) {
						location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

						throw peg$buildStructuredError(
							[peg$otherExpectation(description)],
							input.substring(peg$savedPos, peg$currPos),
							location
						);
					}

					function error(message, location) {
						location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

						throw peg$buildSimpleError(message, location);
					}

					function peg$literalExpectation(text, ignoreCase) {
						return { type: "literal", text: text, ignoreCase: ignoreCase };
					}

					function peg$classExpectation(parts, inverted, ignoreCase) {
						return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
					}

					function peg$anyExpectation() {
						return { type: "any" };
					}

					function peg$endExpectation() {
						return { type: "end" };
					}

					function peg$otherExpectation(description) {
						return { type: "other", description: description };
					}

					function peg$computePosDetails(pos) {
						var details = peg$posDetailsCache[pos], p;

						if (details) {
							return details;
						} else {
							p = pos - 1;
							while (!peg$posDetailsCache[p]) {
								p--;
							}

							details = peg$posDetailsCache[p];
							details = {
								line: details.line,
								column: details.column
							};

							while (p < pos) {
								if (input.charCodeAt(p) === 10) {
									details.line++;
									details.column = 1;
								} else {
									details.column++;
								}

								p++;
							}

							peg$posDetailsCache[pos] = details;
							return details;
						}
					}

					function peg$computeLocation(startPos, endPos) {
						var startPosDetails = peg$computePosDetails(startPos),
							endPosDetails = peg$computePosDetails(endPos);

						return {
							start: {
								offset: startPos,
								line: startPosDetails.line,
								column: startPosDetails.column
							},
							end: {
								offset: endPos,
								line: endPosDetails.line,
								column: endPosDetails.column
							}
						};
					}

					function peg$fail(expected) {
						if (peg$currPos < peg$maxFailPos) { return; }

						if (peg$currPos > peg$maxFailPos) {
							peg$maxFailPos = peg$currPos;
							peg$maxFailExpected = [];
						}

						peg$maxFailExpected.push(expected);
					}

					function peg$buildSimpleError(message, location) {
						return new peg$SyntaxError(message, null, null, location);
					}

					function peg$buildStructuredError(expected, found, location) {
						return new peg$SyntaxError(
							peg$SyntaxError.buildMessage(expected, found),
							expected,
							found,
							location
						);
					}

					function peg$parsegames() {
						var s0, s1, s2, s3, s4, s5, s6, s7;

						s0 = peg$currPos;
						s1 = peg$parsews();
						if (s1 !== peg$FAILED) {
							s2 = peg$currPos;
							s3 = peg$parsegame();
							if (s3 !== peg$FAILED) {
								s4 = [];
								s5 = peg$currPos;
								s6 = peg$parsewsp();
								if (s6 !== peg$FAILED) {
									s7 = peg$parsegame();
									if (s7 !== peg$FAILED) {
										peg$savedPos = s5;
										s6 = peg$c0(s3, s7);
										s5 = s6;
									} else {
										peg$currPos = s5;
										s5 = peg$FAILED;
									}
								} else {
									peg$currPos = s5;
									s5 = peg$FAILED;
								}
								while (s5 !== peg$FAILED) {
									s4.push(s5);
									s5 = peg$currPos;
									s6 = peg$parsewsp();
									if (s6 !== peg$FAILED) {
										s7 = peg$parsegame();
										if (s7 !== peg$FAILED) {
											peg$savedPos = s5;
											s6 = peg$c0(s3, s7);
											s5 = s6;
										} else {
											peg$currPos = s5;
											s5 = peg$FAILED;
										}
									} else {
										peg$currPos = s5;
										s5 = peg$FAILED;
									}
								}
								if (s4 !== peg$FAILED) {
									peg$savedPos = s2;
									s3 = peg$c1(s3, s4);
									s2 = s3;
								} else {
									peg$currPos = s2;
									s2 = peg$FAILED;
								}
							} else {
								peg$currPos = s2;
								s2 = peg$FAILED;
							}
							if (s2 === peg$FAILED) {
								s2 = null;
							}
							if (s2 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c2(s2);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsegame() {
						var s0, s1, s2;

						s0 = peg$currPos;
						s1 = peg$parsetags();
						if (s1 === peg$FAILED) {
							s1 = null;
						}
						if (s1 !== peg$FAILED) {
							s2 = peg$parsepgn();
							if (s2 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c3(s1, s2);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsetags() {
						var s0, s1, s2, s3, s4, s5, s6, s7;

						s0 = peg$currPos;
						s1 = peg$parsews();
						if (s1 !== peg$FAILED) {
							s2 = peg$currPos;
							s3 = peg$parsetag();
							if (s3 !== peg$FAILED) {
								s4 = [];
								s5 = peg$currPos;
								s6 = peg$parsews();
								if (s6 !== peg$FAILED) {
									s7 = peg$parsetag();
									if (s7 !== peg$FAILED) {
										peg$savedPos = s5;
										s6 = peg$c0(s3, s7);
										s5 = s6;
									} else {
										peg$currPos = s5;
										s5 = peg$FAILED;
									}
								} else {
									peg$currPos = s5;
									s5 = peg$FAILED;
								}
								while (s5 !== peg$FAILED) {
									s4.push(s5);
									s5 = peg$currPos;
									s6 = peg$parsews();
									if (s6 !== peg$FAILED) {
										s7 = peg$parsetag();
										if (s7 !== peg$FAILED) {
											peg$savedPos = s5;
											s6 = peg$c0(s3, s7);
											s5 = s6;
										} else {
											peg$currPos = s5;
											s5 = peg$FAILED;
										}
									} else {
										peg$currPos = s5;
										s5 = peg$FAILED;
									}
								}
								if (s4 !== peg$FAILED) {
									peg$savedPos = s2;
									s3 = peg$c4(s3, s4);
									s2 = s3;
								} else {
									peg$currPos = s2;
									s2 = peg$FAILED;
								}
							} else {
								peg$currPos = s2;
								s2 = peg$FAILED;
							}
							if (s2 === peg$FAILED) {
								s2 = null;
							}
							if (s2 !== peg$FAILED) {
								s3 = peg$parsews();
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c5(s2);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsetag() {
						var s0, s1, s2, s3;

						s0 = peg$currPos;
						s1 = peg$parsebl();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsetagKeyValue();
							if (s2 !== peg$FAILED) {
								s3 = peg$parsebr();
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c6(s2);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsetagKeyValue() {
						var s0, s1, s2, s3;

						s0 = peg$currPos;
						s1 = peg$parseeventKey();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsews();
							if (s2 !== peg$FAILED) {
								s3 = peg$parsestring();
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c7(s3);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							s1 = peg$parsesiteKey();
							if (s1 !== peg$FAILED) {
								s2 = peg$parsews();
								if (s2 !== peg$FAILED) {
									s3 = peg$parsestring();
									if (s3 !== peg$FAILED) {
										peg$savedPos = s0;
										s1 = peg$c8(s3);
										s0 = s1;
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
							if (s0 === peg$FAILED) {
								s0 = peg$currPos;
								s1 = peg$parsedateKey();
								if (s1 !== peg$FAILED) {
									s2 = peg$parsews();
									if (s2 !== peg$FAILED) {
										s3 = peg$parsedate();
										if (s3 !== peg$FAILED) {
											peg$savedPos = s0;
											s1 = peg$c9(s3);
											s0 = s1;
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
								if (s0 === peg$FAILED) {
									s0 = peg$currPos;
									s1 = peg$parseroundKey();
									if (s1 !== peg$FAILED) {
										s2 = peg$parsews();
										if (s2 !== peg$FAILED) {
											s3 = peg$parsestring();
											if (s3 !== peg$FAILED) {
												peg$savedPos = s0;
												s1 = peg$c10(s3);
												s0 = s1;
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
									if (s0 === peg$FAILED) {
										s0 = peg$currPos;
										s1 = peg$parsewhiteTitleKey();
										if (s1 !== peg$FAILED) {
											s2 = peg$parsews();
											if (s2 !== peg$FAILED) {
												s3 = peg$parsestring();
												if (s3 !== peg$FAILED) {
													peg$savedPos = s0;
													s1 = peg$c11(s3);
													s0 = s1;
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
										if (s0 === peg$FAILED) {
											s0 = peg$currPos;
											s1 = peg$parseblackTitleKey();
											if (s1 !== peg$FAILED) {
												s2 = peg$parsews();
												if (s2 !== peg$FAILED) {
													s3 = peg$parsestring();
													if (s3 !== peg$FAILED) {
														peg$savedPos = s0;
														s1 = peg$c12(s3);
														s0 = s1;
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
											if (s0 === peg$FAILED) {
												s0 = peg$currPos;
												s1 = peg$parsewhiteEloKey();
												if (s1 !== peg$FAILED) {
													s2 = peg$parsews();
													if (s2 !== peg$FAILED) {
														s3 = peg$parseintegerOrDash();
														if (s3 !== peg$FAILED) {
															peg$savedPos = s0;
															s1 = peg$c13(s3);
															s0 = s1;
														} else {
															peg$currPos = s0;
															s0 = peg$FAILED;
														}
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
												if (s0 === peg$FAILED) {
													s0 = peg$currPos;
													s1 = peg$parseblackEloKey();
													if (s1 !== peg$FAILED) {
														s2 = peg$parsews();
														if (s2 !== peg$FAILED) {
															s3 = peg$parseintegerOrDash();
															if (s3 !== peg$FAILED) {
																peg$savedPos = s0;
																s1 = peg$c14(s3);
																s0 = s1;
															} else {
																peg$currPos = s0;
																s0 = peg$FAILED;
															}
														} else {
															peg$currPos = s0;
															s0 = peg$FAILED;
														}
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
													if (s0 === peg$FAILED) {
														s0 = peg$currPos;
														s1 = peg$parsewhiteUSCFKey();
														if (s1 !== peg$FAILED) {
															s2 = peg$parsews();
															if (s2 !== peg$FAILED) {
																s3 = peg$parseintegerString();
																if (s3 !== peg$FAILED) {
																	peg$savedPos = s0;
																	s1 = peg$c15(s3);
																	s0 = s1;
																} else {
																	peg$currPos = s0;
																	s0 = peg$FAILED;
																}
															} else {
																peg$currPos = s0;
																s0 = peg$FAILED;
															}
														} else {
															peg$currPos = s0;
															s0 = peg$FAILED;
														}
														if (s0 === peg$FAILED) {
															s0 = peg$currPos;
															s1 = peg$parseblackUSCFKey();
															if (s1 !== peg$FAILED) {
																s2 = peg$parsews();
																if (s2 !== peg$FAILED) {
																	s3 = peg$parseintegerString();
																	if (s3 !== peg$FAILED) {
																		peg$savedPos = s0;
																		s1 = peg$c16(s3);
																		s0 = s1;
																	} else {
																		peg$currPos = s0;
																		s0 = peg$FAILED;
																	}
																} else {
																	peg$currPos = s0;
																	s0 = peg$FAILED;
																}
															} else {
																peg$currPos = s0;
																s0 = peg$FAILED;
															}
															if (s0 === peg$FAILED) {
																s0 = peg$currPos;
																s1 = peg$parsewhiteNAKey();
																if (s1 !== peg$FAILED) {
																	s2 = peg$parsews();
																	if (s2 !== peg$FAILED) {
																		s3 = peg$parsestring();
																		if (s3 !== peg$FAILED) {
																			peg$savedPos = s0;
																			s1 = peg$c17(s3);
																			s0 = s1;
																		} else {
																			peg$currPos = s0;
																			s0 = peg$FAILED;
																		}
																	} else {
																		peg$currPos = s0;
																		s0 = peg$FAILED;
																	}
																} else {
																	peg$currPos = s0;
																	s0 = peg$FAILED;
																}
																if (s0 === peg$FAILED) {
																	s0 = peg$currPos;
																	s1 = peg$parseblackNAKey();
																	if (s1 !== peg$FAILED) {
																		s2 = peg$parsews();
																		if (s2 !== peg$FAILED) {
																			s3 = peg$parsestring();
																			if (s3 !== peg$FAILED) {
																				peg$savedPos = s0;
																				s1 = peg$c18(s3);
																				s0 = s1;
																			} else {
																				peg$currPos = s0;
																				s0 = peg$FAILED;
																			}
																		} else {
																			peg$currPos = s0;
																			s0 = peg$FAILED;
																		}
																	} else {
																		peg$currPos = s0;
																		s0 = peg$FAILED;
																	}
																	if (s0 === peg$FAILED) {
																		s0 = peg$currPos;
																		s1 = peg$parsewhiteTypeKey();
																		if (s1 !== peg$FAILED) {
																			s2 = peg$parsews();
																			if (s2 !== peg$FAILED) {
																				s3 = peg$parsestring();
																				if (s3 !== peg$FAILED) {
																					peg$savedPos = s0;
																					s1 = peg$c19(s3);
																					s0 = s1;
																				} else {
																					peg$currPos = s0;
																					s0 = peg$FAILED;
																				}
																			} else {
																				peg$currPos = s0;
																				s0 = peg$FAILED;
																			}
																		} else {
																			peg$currPos = s0;
																			s0 = peg$FAILED;
																		}
																		if (s0 === peg$FAILED) {
																			s0 = peg$currPos;
																			s1 = peg$parseblackTypeKey();
																			if (s1 !== peg$FAILED) {
																				s2 = peg$parsews();
																				if (s2 !== peg$FAILED) {
																					s3 = peg$parsestring();
																					if (s3 !== peg$FAILED) {
																						peg$savedPos = s0;
																						s1 = peg$c20(s3);
																						s0 = s1;
																					} else {
																						peg$currPos = s0;
																						s0 = peg$FAILED;
																					}
																				} else {
																					peg$currPos = s0;
																					s0 = peg$FAILED;
																				}
																			} else {
																				peg$currPos = s0;
																				s0 = peg$FAILED;
																			}
																			if (s0 === peg$FAILED) {
																				s0 = peg$currPos;
																				s1 = peg$parsewhiteKey();
																				if (s1 !== peg$FAILED) {
																					s2 = peg$parsews();
																					if (s2 !== peg$FAILED) {
																						s3 = peg$parsestring();
																						if (s3 !== peg$FAILED) {
																							peg$savedPos = s0;
																							s1 = peg$c21(s3);
																							s0 = s1;
																						} else {
																							peg$currPos = s0;
																							s0 = peg$FAILED;
																						}
																					} else {
																						peg$currPos = s0;
																						s0 = peg$FAILED;
																					}
																				} else {
																					peg$currPos = s0;
																					s0 = peg$FAILED;
																				}
																				if (s0 === peg$FAILED) {
																					s0 = peg$currPos;
																					s1 = peg$parseblackKey();
																					if (s1 !== peg$FAILED) {
																						s2 = peg$parsews();
																						if (s2 !== peg$FAILED) {
																							s3 = peg$parsestring();
																							if (s3 !== peg$FAILED) {
																								peg$savedPos = s0;
																								s1 = peg$c22(s3);
																								s0 = s1;
																							} else {
																								peg$currPos = s0;
																								s0 = peg$FAILED;
																							}
																						} else {
																							peg$currPos = s0;
																							s0 = peg$FAILED;
																						}
																					} else {
																						peg$currPos = s0;
																						s0 = peg$FAILED;
																					}
																					if (s0 === peg$FAILED) {
																						s0 = peg$currPos;
																						s1 = peg$parseresultKey();
																						if (s1 !== peg$FAILED) {
																							s2 = peg$parsews();
																							if (s2 !== peg$FAILED) {
																								s3 = peg$parseresult();
																								if (s3 !== peg$FAILED) {
																									peg$savedPos = s0;
																									s1 = peg$c23(s3);
																									s0 = s1;
																								} else {
																									peg$currPos = s0;
																									s0 = peg$FAILED;
																								}
																							} else {
																								peg$currPos = s0;
																								s0 = peg$FAILED;
																							}
																						} else {
																							peg$currPos = s0;
																							s0 = peg$FAILED;
																						}
																						if (s0 === peg$FAILED) {
																							s0 = peg$currPos;
																							s1 = peg$parseeventDateKey();
																							if (s1 !== peg$FAILED) {
																								s2 = peg$parsews();
																								if (s2 !== peg$FAILED) {
																									s3 = peg$parsedate();
																									if (s3 !== peg$FAILED) {
																										peg$savedPos = s0;
																										s1 = peg$c24(s3);
																										s0 = s1;
																									} else {
																										peg$currPos = s0;
																										s0 = peg$FAILED;
																									}
																								} else {
																									peg$currPos = s0;
																									s0 = peg$FAILED;
																								}
																							} else {
																								peg$currPos = s0;
																								s0 = peg$FAILED;
																							}
																							if (s0 === peg$FAILED) {
																								s0 = peg$currPos;
																								s1 = peg$parseeventSponsorKey();
																								if (s1 !== peg$FAILED) {
																									s2 = peg$parsews();
																									if (s2 !== peg$FAILED) {
																										s3 = peg$parsestring();
																										if (s3 !== peg$FAILED) {
																											peg$savedPos = s0;
																											s1 = peg$c25(s3);
																											s0 = s1;
																										} else {
																											peg$currPos = s0;
																											s0 = peg$FAILED;
																										}
																									} else {
																										peg$currPos = s0;
																										s0 = peg$FAILED;
																									}
																								} else {
																									peg$currPos = s0;
																									s0 = peg$FAILED;
																								}
																								if (s0 === peg$FAILED) {
																									s0 = peg$currPos;
																									s1 = peg$parsesectionKey();
																									if (s1 !== peg$FAILED) {
																										s2 = peg$parsews();
																										if (s2 !== peg$FAILED) {
																											s3 = peg$parsestring();
																											if (s3 !== peg$FAILED) {
																												peg$savedPos = s0;
																												s1 = peg$c26(s3);
																												s0 = s1;
																											} else {
																												peg$currPos = s0;
																												s0 = peg$FAILED;
																											}
																										} else {
																											peg$currPos = s0;
																											s0 = peg$FAILED;
																										}
																									} else {
																										peg$currPos = s0;
																										s0 = peg$FAILED;
																									}
																									if (s0 === peg$FAILED) {
																										s0 = peg$currPos;
																										s1 = peg$parsestageKey();
																										if (s1 !== peg$FAILED) {
																											s2 = peg$parsews();
																											if (s2 !== peg$FAILED) {
																												s3 = peg$parsestring();
																												if (s3 !== peg$FAILED) {
																													peg$savedPos = s0;
																													s1 = peg$c27(s3);
																													s0 = s1;
																												} else {
																													peg$currPos = s0;
																													s0 = peg$FAILED;
																												}
																											} else {
																												peg$currPos = s0;
																												s0 = peg$FAILED;
																											}
																										} else {
																											peg$currPos = s0;
																											s0 = peg$FAILED;
																										}
																										if (s0 === peg$FAILED) {
																											s0 = peg$currPos;
																											s1 = peg$parseboardKey();
																											if (s1 !== peg$FAILED) {
																												s2 = peg$parsews();
																												if (s2 !== peg$FAILED) {
																													s3 = peg$parseintegerString();
																													if (s3 !== peg$FAILED) {
																														peg$savedPos = s0;
																														s1 = peg$c28(s3);
																														s0 = s1;
																													} else {
																														peg$currPos = s0;
																														s0 = peg$FAILED;
																													}
																												} else {
																													peg$currPos = s0;
																													s0 = peg$FAILED;
																												}
																											} else {
																												peg$currPos = s0;
																												s0 = peg$FAILED;
																											}
																											if (s0 === peg$FAILED) {
																												s0 = peg$currPos;
																												s1 = peg$parseopeningKey();
																												if (s1 !== peg$FAILED) {
																													s2 = peg$parsews();
																													if (s2 !== peg$FAILED) {
																														s3 = peg$parsestring();
																														if (s3 !== peg$FAILED) {
																															peg$savedPos = s0;
																															s1 = peg$c29(s3);
																															s0 = s1;
																														} else {
																															peg$currPos = s0;
																															s0 = peg$FAILED;
																														}
																													} else {
																														peg$currPos = s0;
																														s0 = peg$FAILED;
																													}
																												} else {
																													peg$currPos = s0;
																													s0 = peg$FAILED;
																												}
																												if (s0 === peg$FAILED) {
																													s0 = peg$currPos;
																													s1 = peg$parsevariationKey();
																													if (s1 !== peg$FAILED) {
																														s2 = peg$parsews();
																														if (s2 !== peg$FAILED) {
																															s3 = peg$parsestring();
																															if (s3 !== peg$FAILED) {
																																peg$savedPos = s0;
																																s1 = peg$c30(s3);
																																s0 = s1;
																															} else {
																																peg$currPos = s0;
																																s0 = peg$FAILED;
																															}
																														} else {
																															peg$currPos = s0;
																															s0 = peg$FAILED;
																														}
																													} else {
																														peg$currPos = s0;
																														s0 = peg$FAILED;
																													}
																													if (s0 === peg$FAILED) {
																														s0 = peg$currPos;
																														s1 = peg$parsesubVariationKey();
																														if (s1 !== peg$FAILED) {
																															s2 = peg$parsews();
																															if (s2 !== peg$FAILED) {
																																s3 = peg$parsestring();
																																if (s3 !== peg$FAILED) {
																																	peg$savedPos = s0;
																																	s1 = peg$c31(s3);
																																	s0 = s1;
																																} else {
																																	peg$currPos = s0;
																																	s0 = peg$FAILED;
																																}
																															} else {
																																peg$currPos = s0;
																																s0 = peg$FAILED;
																															}
																														} else {
																															peg$currPos = s0;
																															s0 = peg$FAILED;
																														}
																														if (s0 === peg$FAILED) {
																															s0 = peg$currPos;
																															s1 = peg$parseecoKey();
																															if (s1 !== peg$FAILED) {
																																s2 = peg$parsews();
																																if (s2 !== peg$FAILED) {
																																	s3 = peg$parsestring();
																																	if (s3 !== peg$FAILED) {
																																		peg$savedPos = s0;
																																		s1 = peg$c32(s3);
																																		s0 = s1;
																																	} else {
																																		peg$currPos = s0;
																																		s0 = peg$FAILED;
																																	}
																																} else {
																																	peg$currPos = s0;
																																	s0 = peg$FAILED;
																																}
																															} else {
																																peg$currPos = s0;
																																s0 = peg$FAILED;
																															}
																															if (s0 === peg$FAILED) {
																																s0 = peg$currPos;
																																s1 = peg$parsenicKey();
																																if (s1 !== peg$FAILED) {
																																	s2 = peg$parsews();
																																	if (s2 !== peg$FAILED) {
																																		s3 = peg$parsestring();
																																		if (s3 !== peg$FAILED) {
																																			peg$savedPos = s0;
																																			s1 = peg$c33(s3);
																																			s0 = s1;
																																		} else {
																																			peg$currPos = s0;
																																			s0 = peg$FAILED;
																																		}
																																	} else {
																																		peg$currPos = s0;
																																		s0 = peg$FAILED;
																																	}
																																} else {
																																	peg$currPos = s0;
																																	s0 = peg$FAILED;
																																}
																																if (s0 === peg$FAILED) {
																																	s0 = peg$currPos;
																																	s1 = peg$parsetimeKey();
																																	if (s1 !== peg$FAILED) {
																																		s2 = peg$parsews();
																																		if (s2 !== peg$FAILED) {
																																			s3 = peg$parsestring();
																																			if (s3 !== peg$FAILED) {
																																				peg$savedPos = s0;
																																				s1 = peg$c34(s3);
																																				s0 = s1;
																																			} else {
																																				peg$currPos = s0;
																																				s0 = peg$FAILED;
																																			}
																																		} else {
																																			peg$currPos = s0;
																																			s0 = peg$FAILED;
																																		}
																																	} else {
																																		peg$currPos = s0;
																																		s0 = peg$FAILED;
																																	}
																																	if (s0 === peg$FAILED) {
																																		s0 = peg$currPos;
																																		s1 = peg$parseutcTimeKey();
																																		if (s1 !== peg$FAILED) {
																																			s2 = peg$parsews();
																																			if (s2 !== peg$FAILED) {
																																				s3 = peg$parsestring();
																																				if (s3 !== peg$FAILED) {
																																					peg$savedPos = s0;
																																					s1 = peg$c35(s3);
																																					s0 = s1;
																																				} else {
																																					peg$currPos = s0;
																																					s0 = peg$FAILED;
																																				}
																																			} else {
																																				peg$currPos = s0;
																																				s0 = peg$FAILED;
																																			}
																																		} else {
																																			peg$currPos = s0;
																																			s0 = peg$FAILED;
																																		}
																																		if (s0 === peg$FAILED) {
																																			s0 = peg$currPos;
																																			s1 = peg$parseutcDateKey();
																																			if (s1 !== peg$FAILED) {
																																				s2 = peg$parsews();
																																				if (s2 !== peg$FAILED) {
																																					s3 = peg$parsestring();
																																					if (s3 !== peg$FAILED) {
																																						peg$savedPos = s0;
																																						s1 = peg$c36(s3);
																																						s0 = s1;
																																					} else {
																																						peg$currPos = s0;
																																						s0 = peg$FAILED;
																																					}
																																				} else {
																																					peg$currPos = s0;
																																					s0 = peg$FAILED;
																																				}
																																			} else {
																																				peg$currPos = s0;
																																				s0 = peg$FAILED;
																																			}
																																			if (s0 === peg$FAILED) {
																																				s0 = peg$currPos;
																																				s1 = peg$parsetimeControlKey();
																																				if (s1 !== peg$FAILED) {
																																					s2 = peg$parsews();
																																					if (s2 !== peg$FAILED) {
																																						s3 = peg$parsestring();
																																						if (s3 !== peg$FAILED) {
																																							peg$savedPos = s0;
																																							s1 = peg$c37(s3);
																																							s0 = s1;
																																						} else {
																																							peg$currPos = s0;
																																							s0 = peg$FAILED;
																																						}
																																					} else {
																																						peg$currPos = s0;
																																						s0 = peg$FAILED;
																																					}
																																				} else {
																																					peg$currPos = s0;
																																					s0 = peg$FAILED;
																																				}
																																				if (s0 === peg$FAILED) {
																																					s0 = peg$currPos;
																																					s1 = peg$parsesetUpKey();
																																					if (s1 !== peg$FAILED) {
																																						s2 = peg$parsews();
																																						if (s2 !== peg$FAILED) {
																																							s3 = peg$parsestring();
																																							if (s3 !== peg$FAILED) {
																																								peg$savedPos = s0;
																																								s1 = peg$c38(s3);
																																								s0 = s1;
																																							} else {
																																								peg$currPos = s0;
																																								s0 = peg$FAILED;
																																							}
																																						} else {
																																							peg$currPos = s0;
																																							s0 = peg$FAILED;
																																						}
																																					} else {
																																						peg$currPos = s0;
																																						s0 = peg$FAILED;
																																					}
																																					if (s0 === peg$FAILED) {
																																						s0 = peg$currPos;
																																						s1 = peg$parsefenKey();
																																						if (s1 !== peg$FAILED) {
																																							s2 = peg$parsews();
																																							if (s2 !== peg$FAILED) {
																																								s3 = peg$parsestring();
																																								if (s3 !== peg$FAILED) {
																																									peg$savedPos = s0;
																																									s1 = peg$c39(s3);
																																									s0 = s1;
																																								} else {
																																									peg$currPos = s0;
																																									s0 = peg$FAILED;
																																								}
																																							} else {
																																								peg$currPos = s0;
																																								s0 = peg$FAILED;
																																							}
																																						} else {
																																							peg$currPos = s0;
																																							s0 = peg$FAILED;
																																						}
																																						if (s0 === peg$FAILED) {
																																							s0 = peg$currPos;
																																							s1 = peg$parseterminationKey();
																																							if (s1 !== peg$FAILED) {
																																								s2 = peg$parsews();
																																								if (s2 !== peg$FAILED) {
																																									s3 = peg$parsestring();
																																									if (s3 !== peg$FAILED) {
																																										peg$savedPos = s0;
																																										s1 = peg$c40(s3);
																																										s0 = s1;
																																									} else {
																																										peg$currPos = s0;
																																										s0 = peg$FAILED;
																																									}
																																								} else {
																																									peg$currPos = s0;
																																									s0 = peg$FAILED;
																																								}
																																							} else {
																																								peg$currPos = s0;
																																								s0 = peg$FAILED;
																																							}
																																							if (s0 === peg$FAILED) {
																																								s0 = peg$currPos;
																																								s1 = peg$parseanotatorKey();
																																								if (s1 !== peg$FAILED) {
																																									s2 = peg$parsews();
																																									if (s2 !== peg$FAILED) {
																																										s3 = peg$parsestring();
																																										if (s3 !== peg$FAILED) {
																																											peg$savedPos = s0;
																																											s1 = peg$c41(s3);
																																											s0 = s1;
																																										} else {
																																											peg$currPos = s0;
																																											s0 = peg$FAILED;
																																										}
																																									} else {
																																										peg$currPos = s0;
																																										s0 = peg$FAILED;
																																									}
																																								} else {
																																									peg$currPos = s0;
																																									s0 = peg$FAILED;
																																								}
																																								if (s0 === peg$FAILED) {
																																									s0 = peg$currPos;
																																									s1 = peg$parsemodeKey();
																																									if (s1 !== peg$FAILED) {
																																										s2 = peg$parsews();
																																										if (s2 !== peg$FAILED) {
																																											s3 = peg$parsestring();
																																											if (s3 !== peg$FAILED) {
																																												peg$savedPos = s0;
																																												s1 = peg$c42(s3);
																																												s0 = s1;
																																											} else {
																																												peg$currPos = s0;
																																												s0 = peg$FAILED;
																																											}
																																										} else {
																																											peg$currPos = s0;
																																											s0 = peg$FAILED;
																																										}
																																									} else {
																																										peg$currPos = s0;
																																										s0 = peg$FAILED;
																																									}
																																									if (s0 === peg$FAILED) {
																																										s0 = peg$currPos;
																																										s1 = peg$parseplyCountKey();
																																										if (s1 !== peg$FAILED) {
																																											s2 = peg$parsews();
																																											if (s2 !== peg$FAILED) {
																																												s3 = peg$parseintegerString();
																																												if (s3 !== peg$FAILED) {
																																													peg$savedPos = s0;
																																													s1 = peg$c43(s3);
																																													s0 = s1;
																																												} else {
																																													peg$currPos = s0;
																																													s0 = peg$FAILED;
																																												}
																																											} else {
																																												peg$currPos = s0;
																																												s0 = peg$FAILED;
																																											}
																																										} else {
																																											peg$currPos = s0;
																																											s0 = peg$FAILED;
																																										}
																																										if (s0 === peg$FAILED) {
																																											s0 = peg$currPos;
																																											s1 = peg$parsestringNoQuot();
																																											if (s1 !== peg$FAILED) {
																																												s2 = peg$parsews();
																																												if (s2 !== peg$FAILED) {
																																													s3 = peg$parsestring();
																																													if (s3 !== peg$FAILED) {
																																														peg$savedPos = s0;
																																														s1 = peg$c44(s1, s3);
																																														s0 = s1;
																																													} else {
																																														peg$currPos = s0;
																																														s0 = peg$FAILED;
																																													}
																																												} else {
																																													peg$currPos = s0;
																																													s0 = peg$FAILED;
																																												}
																																											} else {
																																												peg$currPos = s0;
																																												s0 = peg$FAILED;
																																											}
																																										}
																																									}
																																								}
																																							}
																																						}
																																					}
																																				}
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}

						return s0;
					}

					function peg$parseeventKey() {
						var s0;

						if (input.substr(peg$currPos, 5) === peg$c45) {
							s0 = peg$c45;
							peg$currPos += 5;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c46); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 5) === peg$c47) {
								s0 = peg$c47;
								peg$currPos += 5;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c48); }
							}
						}

						return s0;
					}

					function peg$parsesiteKey() {
						var s0;

						if (input.substr(peg$currPos, 4) === peg$c49) {
							s0 = peg$c49;
							peg$currPos += 4;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c50); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 4) === peg$c51) {
								s0 = peg$c51;
								peg$currPos += 4;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c52); }
							}
						}

						return s0;
					}

					function peg$parsedateKey() {
						var s0;

						if (input.substr(peg$currPos, 4) === peg$c53) {
							s0 = peg$c53;
							peg$currPos += 4;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c54); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 4) === peg$c55) {
								s0 = peg$c55;
								peg$currPos += 4;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c56); }
							}
						}

						return s0;
					}

					function peg$parseroundKey() {
						var s0;

						if (input.substr(peg$currPos, 5) === peg$c57) {
							s0 = peg$c57;
							peg$currPos += 5;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c58); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 5) === peg$c59) {
								s0 = peg$c59;
								peg$currPos += 5;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c60); }
							}
						}

						return s0;
					}

					function peg$parsewhiteKey() {
						var s0;

						if (input.substr(peg$currPos, 5) === peg$c61) {
							s0 = peg$c61;
							peg$currPos += 5;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c62); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 5) === peg$c61) {
								s0 = peg$c61;
								peg$currPos += 5;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c62); }
							}
						}

						return s0;
					}

					function peg$parseblackKey() {
						var s0;

						if (input.substr(peg$currPos, 5) === peg$c63) {
							s0 = peg$c63;
							peg$currPos += 5;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c64); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 5) === peg$c65) {
								s0 = peg$c65;
								peg$currPos += 5;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c66); }
							}
						}

						return s0;
					}

					function peg$parseresultKey() {
						var s0;

						if (input.substr(peg$currPos, 6) === peg$c67) {
							s0 = peg$c67;
							peg$currPos += 6;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c68); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 6) === peg$c69) {
								s0 = peg$c69;
								peg$currPos += 6;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c70); }
							}
						}

						return s0;
					}

					function peg$parsewhiteTitleKey() {
						var s0;

						if (input.substr(peg$currPos, 10) === peg$c71) {
							s0 = peg$c71;
							peg$currPos += 10;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c72); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 10) === peg$c73) {
								s0 = peg$c73;
								peg$currPos += 10;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c74); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 10) === peg$c75) {
									s0 = peg$c75;
									peg$currPos += 10;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c76); }
								}
							}
						}

						return s0;
					}

					function peg$parseblackTitleKey() {
						var s0;

						if (input.substr(peg$currPos, 10) === peg$c77) {
							s0 = peg$c77;
							peg$currPos += 10;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c78); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 10) === peg$c79) {
								s0 = peg$c79;
								peg$currPos += 10;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c80); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 10) === peg$c81) {
									s0 = peg$c81;
									peg$currPos += 10;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c82); }
								}
							}
						}

						return s0;
					}

					function peg$parsewhiteEloKey() {
						var s0;

						if (input.substr(peg$currPos, 8) === peg$c83) {
							s0 = peg$c83;
							peg$currPos += 8;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c84); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 8) === peg$c85) {
								s0 = peg$c85;
								peg$currPos += 8;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c86); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 8) === peg$c87) {
									s0 = peg$c87;
									peg$currPos += 8;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c88); }
								}
								if (s0 === peg$FAILED) {
									if (input.substr(peg$currPos, 8) === peg$c89) {
										s0 = peg$c89;
										peg$currPos += 8;
									} else {
										s0 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c90); }
									}
								}
							}
						}

						return s0;
					}

					function peg$parseblackEloKey() {
						var s0;

						if (input.substr(peg$currPos, 8) === peg$c91) {
							s0 = peg$c91;
							peg$currPos += 8;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c92); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 8) === peg$c93) {
								s0 = peg$c93;
								peg$currPos += 8;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c94); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 8) === peg$c95) {
									s0 = peg$c95;
									peg$currPos += 8;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c96); }
								}
								if (s0 === peg$FAILED) {
									if (input.substr(peg$currPos, 8) === peg$c97) {
										s0 = peg$c97;
										peg$currPos += 8;
									} else {
										s0 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c98); }
									}
								}
							}
						}

						return s0;
					}

					function peg$parsewhiteUSCFKey() {
						var s0;

						if (input.substr(peg$currPos, 9) === peg$c99) {
							s0 = peg$c99;
							peg$currPos += 9;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c100); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 9) === peg$c101) {
								s0 = peg$c101;
								peg$currPos += 9;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c102); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 9) === peg$c103) {
									s0 = peg$c103;
									peg$currPos += 9;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c104); }
								}
								if (s0 === peg$FAILED) {
									if (input.substr(peg$currPos, 9) === peg$c105) {
										s0 = peg$c105;
										peg$currPos += 9;
									} else {
										s0 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c106); }
									}
								}
							}
						}

						return s0;
					}

					function peg$parseblackUSCFKey() {
						var s0;

						if (input.substr(peg$currPos, 9) === peg$c107) {
							s0 = peg$c107;
							peg$currPos += 9;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c108); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 9) === peg$c109) {
								s0 = peg$c109;
								peg$currPos += 9;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c110); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 9) === peg$c111) {
									s0 = peg$c111;
									peg$currPos += 9;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c112); }
								}
								if (s0 === peg$FAILED) {
									if (input.substr(peg$currPos, 9) === peg$c113) {
										s0 = peg$c113;
										peg$currPos += 9;
									} else {
										s0 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c114); }
									}
								}
							}
						}

						return s0;
					}

					function peg$parsewhiteNAKey() {
						var s0;

						if (input.substr(peg$currPos, 7) === peg$c115) {
							s0 = peg$c115;
							peg$currPos += 7;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c116); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 7) === peg$c117) {
								s0 = peg$c117;
								peg$currPos += 7;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c118); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 7) === peg$c119) {
									s0 = peg$c119;
									peg$currPos += 7;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c120); }
								}
								if (s0 === peg$FAILED) {
									if (input.substr(peg$currPos, 7) === peg$c121) {
										s0 = peg$c121;
										peg$currPos += 7;
									} else {
										s0 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c122); }
									}
								}
							}
						}

						return s0;
					}

					function peg$parseblackNAKey() {
						var s0;

						if (input.substr(peg$currPos, 7) === peg$c123) {
							s0 = peg$c123;
							peg$currPos += 7;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c124); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 7) === peg$c125) {
								s0 = peg$c125;
								peg$currPos += 7;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c126); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 7) === peg$c127) {
									s0 = peg$c127;
									peg$currPos += 7;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c128); }
								}
								if (s0 === peg$FAILED) {
									if (input.substr(peg$currPos, 7) === peg$c129) {
										s0 = peg$c129;
										peg$currPos += 7;
									} else {
										s0 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c130); }
									}
								}
							}
						}

						return s0;
					}

					function peg$parsewhiteTypeKey() {
						var s0;

						if (input.substr(peg$currPos, 9) === peg$c131) {
							s0 = peg$c131;
							peg$currPos += 9;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c132); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 9) === peg$c133) {
								s0 = peg$c133;
								peg$currPos += 9;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c134); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 9) === peg$c135) {
									s0 = peg$c135;
									peg$currPos += 9;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c136); }
								}
							}
						}

						return s0;
					}

					function peg$parseblackTypeKey() {
						var s0;

						if (input.substr(peg$currPos, 9) === peg$c137) {
							s0 = peg$c137;
							peg$currPos += 9;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c138); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 9) === peg$c139) {
								s0 = peg$c139;
								peg$currPos += 9;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c140); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 9) === peg$c141) {
									s0 = peg$c141;
									peg$currPos += 9;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c142); }
								}
							}
						}

						return s0;
					}

					function peg$parseeventDateKey() {
						var s0;

						if (input.substr(peg$currPos, 9) === peg$c143) {
							s0 = peg$c143;
							peg$currPos += 9;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c144); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 9) === peg$c145) {
								s0 = peg$c145;
								peg$currPos += 9;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c146); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 9) === peg$c147) {
									s0 = peg$c147;
									peg$currPos += 9;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c148); }
								}
							}
						}

						return s0;
					}

					function peg$parseeventSponsorKey() {
						var s0;

						if (input.substr(peg$currPos, 12) === peg$c149) {
							s0 = peg$c149;
							peg$currPos += 12;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c150); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 12) === peg$c151) {
								s0 = peg$c151;
								peg$currPos += 12;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c152); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 12) === peg$c153) {
									s0 = peg$c153;
									peg$currPos += 12;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c154); }
								}
							}
						}

						return s0;
					}

					function peg$parsesectionKey() {
						var s0;

						if (input.substr(peg$currPos, 7) === peg$c155) {
							s0 = peg$c155;
							peg$currPos += 7;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c156); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 7) === peg$c157) {
								s0 = peg$c157;
								peg$currPos += 7;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c158); }
							}
						}

						return s0;
					}

					function peg$parsestageKey() {
						var s0;

						if (input.substr(peg$currPos, 5) === peg$c159) {
							s0 = peg$c159;
							peg$currPos += 5;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c160); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 5) === peg$c161) {
								s0 = peg$c161;
								peg$currPos += 5;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c162); }
							}
						}

						return s0;
					}

					function peg$parseboardKey() {
						var s0;

						if (input.substr(peg$currPos, 5) === peg$c163) {
							s0 = peg$c163;
							peg$currPos += 5;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c164); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 5) === peg$c165) {
								s0 = peg$c165;
								peg$currPos += 5;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c166); }
							}
						}

						return s0;
					}

					function peg$parseopeningKey() {
						var s0;

						if (input.substr(peg$currPos, 7) === peg$c167) {
							s0 = peg$c167;
							peg$currPos += 7;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c168); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 7) === peg$c169) {
								s0 = peg$c169;
								peg$currPos += 7;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c170); }
							}
						}

						return s0;
					}

					function peg$parsevariationKey() {
						var s0;

						if (input.substr(peg$currPos, 9) === peg$c171) {
							s0 = peg$c171;
							peg$currPos += 9;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c172); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 9) === peg$c173) {
								s0 = peg$c173;
								peg$currPos += 9;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c174); }
							}
						}

						return s0;
					}

					function peg$parsesubVariationKey() {
						var s0;

						if (input.substr(peg$currPos, 12) === peg$c175) {
							s0 = peg$c175;
							peg$currPos += 12;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c176); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 12) === peg$c177) {
								s0 = peg$c177;
								peg$currPos += 12;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c178); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 12) === peg$c179) {
									s0 = peg$c179;
									peg$currPos += 12;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c180); }
								}
							}
						}

						return s0;
					}

					function peg$parseecoKey() {
						var s0;

						if (input.substr(peg$currPos, 3) === peg$c181) {
							s0 = peg$c181;
							peg$currPos += 3;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c182); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 3) === peg$c183) {
								s0 = peg$c183;
								peg$currPos += 3;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c184); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 3) === peg$c185) {
									s0 = peg$c185;
									peg$currPos += 3;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c186); }
								}
							}
						}

						return s0;
					}

					function peg$parsenicKey() {
						var s0;

						if (input.substr(peg$currPos, 3) === peg$c187) {
							s0 = peg$c187;
							peg$currPos += 3;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c188); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 3) === peg$c189) {
								s0 = peg$c189;
								peg$currPos += 3;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c190); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 3) === peg$c191) {
									s0 = peg$c191;
									peg$currPos += 3;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c192); }
								}
							}
						}

						return s0;
					}

					function peg$parsetimeKey() {
						var s0;

						if (input.substr(peg$currPos, 4) === peg$c193) {
							s0 = peg$c193;
							peg$currPos += 4;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c194); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 4) === peg$c195) {
								s0 = peg$c195;
								peg$currPos += 4;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c196); }
							}
						}

						return s0;
					}

					function peg$parseutcTimeKey() {
						var s0;

						if (input.substr(peg$currPos, 7) === peg$c197) {
							s0 = peg$c197;
							peg$currPos += 7;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c198); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 7) === peg$c199) {
								s0 = peg$c199;
								peg$currPos += 7;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c200); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 7) === peg$c201) {
									s0 = peg$c201;
									peg$currPos += 7;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c202); }
								}
								if (s0 === peg$FAILED) {
									if (input.substr(peg$currPos, 7) === peg$c203) {
										s0 = peg$c203;
										peg$currPos += 7;
									} else {
										s0 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c204); }
									}
									if (s0 === peg$FAILED) {
										if (input.substr(peg$currPos, 7) === peg$c205) {
											s0 = peg$c205;
											peg$currPos += 7;
										} else {
											s0 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$c206); }
										}
									}
								}
							}
						}

						return s0;
					}

					function peg$parseutcDateKey() {
						var s0;

						if (input.substr(peg$currPos, 7) === peg$c207) {
							s0 = peg$c207;
							peg$currPos += 7;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c208); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 7) === peg$c209) {
								s0 = peg$c209;
								peg$currPos += 7;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c210); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 7) === peg$c211) {
									s0 = peg$c211;
									peg$currPos += 7;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c212); }
								}
								if (s0 === peg$FAILED) {
									if (input.substr(peg$currPos, 7) === peg$c213) {
										s0 = peg$c213;
										peg$currPos += 7;
									} else {
										s0 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c214); }
									}
									if (s0 === peg$FAILED) {
										if (input.substr(peg$currPos, 7) === peg$c215) {
											s0 = peg$c215;
											peg$currPos += 7;
										} else {
											s0 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$c216); }
										}
									}
								}
							}
						}

						return s0;
					}

					function peg$parsetimeControlKey() {
						var s0;

						if (input.substr(peg$currPos, 11) === peg$c217) {
							s0 = peg$c217;
							peg$currPos += 11;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c218); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 11) === peg$c219) {
								s0 = peg$c219;
								peg$currPos += 11;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c220); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 11) === peg$c221) {
									s0 = peg$c221;
									peg$currPos += 11;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c222); }
								}
							}
						}

						return s0;
					}

					function peg$parsesetUpKey() {
						var s0;

						if (input.substr(peg$currPos, 5) === peg$c223) {
							s0 = peg$c223;
							peg$currPos += 5;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c224); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 5) === peg$c225) {
								s0 = peg$c225;
								peg$currPos += 5;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c226); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 5) === peg$c227) {
									s0 = peg$c227;
									peg$currPos += 5;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c228); }
								}
							}
						}

						return s0;
					}

					function peg$parsefenKey() {
						var s0;

						if (input.substr(peg$currPos, 3) === peg$c229) {
							s0 = peg$c229;
							peg$currPos += 3;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c230); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 3) === peg$c231) {
								s0 = peg$c231;
								peg$currPos += 3;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c232); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 3) === peg$c233) {
									s0 = peg$c233;
									peg$currPos += 3;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c234); }
								}
							}
						}

						return s0;
					}

					function peg$parseterminationKey() {
						var s0;

						if (input.substr(peg$currPos, 11) === peg$c235) {
							s0 = peg$c235;
							peg$currPos += 11;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c236); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 11) === peg$c237) {
								s0 = peg$c237;
								peg$currPos += 11;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c238); }
							}
						}

						return s0;
					}

					function peg$parseanotatorKey() {
						var s0;

						if (input.substr(peg$currPos, 9) === peg$c239) {
							s0 = peg$c239;
							peg$currPos += 9;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c240); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 9) === peg$c241) {
								s0 = peg$c241;
								peg$currPos += 9;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c242); }
							}
						}

						return s0;
					}

					function peg$parsemodeKey() {
						var s0;

						if (input.substr(peg$currPos, 4) === peg$c243) {
							s0 = peg$c243;
							peg$currPos += 4;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c244); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 4) === peg$c245) {
								s0 = peg$c245;
								peg$currPos += 4;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c246); }
							}
						}

						return s0;
					}

					function peg$parseplyCountKey() {
						var s0;

						if (input.substr(peg$currPos, 8) === peg$c247) {
							s0 = peg$c247;
							peg$currPos += 8;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c248); }
						}
						if (s0 === peg$FAILED) {
							if (input.substr(peg$currPos, 8) === peg$c249) {
								s0 = peg$c249;
								peg$currPos += 8;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c250); }
							}
							if (s0 === peg$FAILED) {
								if (input.substr(peg$currPos, 8) === peg$c251) {
									s0 = peg$c251;
									peg$currPos += 8;
								} else {
									s0 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c252); }
								}
							}
						}

						return s0;
					}

					function peg$parsews() {
						var s0, s1;

						peg$silentFails++;
						s0 = [];
						if (peg$c254.test(input.charAt(peg$currPos))) {
							s1 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c255); }
						}
						while (s1 !== peg$FAILED) {
							s0.push(s1);
							if (peg$c254.test(input.charAt(peg$currPos))) {
								s1 = input.charAt(peg$currPos);
								peg$currPos++;
							} else {
								s1 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c255); }
							}
						}
						peg$silentFails--;
						if (s0 === peg$FAILED) {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c253); }
						}

						return s0;
					}

					function peg$parsewsp() {
						var s0, s1;

						s0 = [];
						if (peg$c254.test(input.charAt(peg$currPos))) {
							s1 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c255); }
						}
						if (s1 !== peg$FAILED) {
							while (s1 !== peg$FAILED) {
								s0.push(s1);
								if (peg$c254.test(input.charAt(peg$currPos))) {
									s1 = input.charAt(peg$currPos);
									peg$currPos++;
								} else {
									s1 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c255); }
								}
							}
						} else {
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parseeol() {
						var s0, s1;

						s0 = [];
						if (peg$c256.test(input.charAt(peg$currPos))) {
							s1 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c257); }
						}
						if (s1 !== peg$FAILED) {
							while (s1 !== peg$FAILED) {
								s0.push(s1);
								if (peg$c256.test(input.charAt(peg$currPos))) {
									s1 = input.charAt(peg$currPos);
									peg$currPos++;
								} else {
									s1 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c257); }
								}
							}
						} else {
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsestring() {
						var s0, s1, s2, s3;

						peg$silentFails++;
						s0 = peg$currPos;
						s1 = peg$parsequotation_mark();
						if (s1 !== peg$FAILED) {
							s2 = [];
							s3 = peg$parsechar();
							while (s3 !== peg$FAILED) {
								s2.push(s3);
								s3 = peg$parsechar();
							}
							if (s2 !== peg$FAILED) {
								s3 = peg$parsequotation_mark();
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c259(s2);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
						peg$silentFails--;
						if (s0 === peg$FAILED) {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c258); }
						}

						return s0;
					}

					function peg$parsestringNoQuot() {
						var s0, s1, s2;

						s0 = peg$currPos;
						s1 = [];
						if (peg$c260.test(input.charAt(peg$currPos))) {
							s2 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s2 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c261); }
						}
						while (s2 !== peg$FAILED) {
							s1.push(s2);
							if (peg$c260.test(input.charAt(peg$currPos))) {
								s2 = input.charAt(peg$currPos);
								peg$currPos++;
							} else {
								s2 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c261); }
							}
						}
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c259(s1);
						}
						s0 = s1;

						return s0;
					}

					function peg$parsequotation_mark() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 34) {
							s0 = peg$c262;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c263); }
						}

						return s0;
					}

					function peg$parsechar() {
						var s0;

						if (peg$c264.test(input.charAt(peg$currPos))) {
							s0 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c265); }
						}

						return s0;
					}

					function peg$parsedate() {
						var s0, s1, s2, s3, s4, s5, s6, s7, s8;

						s0 = peg$currPos;
						s1 = peg$parsequotation_mark();
						if (s1 !== peg$FAILED) {
							s2 = peg$currPos;
							if (peg$c266.test(input.charAt(peg$currPos))) {
								s3 = input.charAt(peg$currPos);
								peg$currPos++;
							} else {
								s3 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c267); }
							}
							if (s3 !== peg$FAILED) {
								if (peg$c266.test(input.charAt(peg$currPos))) {
									s4 = input.charAt(peg$currPos);
									peg$currPos++;
								} else {
									s4 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c267); }
								}
								if (s4 !== peg$FAILED) {
									if (peg$c266.test(input.charAt(peg$currPos))) {
										s5 = input.charAt(peg$currPos);
										peg$currPos++;
									} else {
										s5 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c267); }
									}
									if (s5 !== peg$FAILED) {
										if (peg$c266.test(input.charAt(peg$currPos))) {
											s6 = input.charAt(peg$currPos);
											peg$currPos++;
										} else {
											s6 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$c267); }
										}
										if (s6 !== peg$FAILED) {
											s3 = [s3, s4, s5, s6];
											s2 = s3;
										} else {
											peg$currPos = s2;
											s2 = peg$FAILED;
										}
									} else {
										peg$currPos = s2;
										s2 = peg$FAILED;
									}
								} else {
									peg$currPos = s2;
									s2 = peg$FAILED;
								}
							} else {
								peg$currPos = s2;
								s2 = peg$FAILED;
							}
							if (s2 !== peg$FAILED) {
								if (input.charCodeAt(peg$currPos) === 46) {
									s3 = peg$c268;
									peg$currPos++;
								} else {
									s3 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c269); }
								}
								if (s3 !== peg$FAILED) {
									s4 = peg$currPos;
									if (peg$c266.test(input.charAt(peg$currPos))) {
										s5 = input.charAt(peg$currPos);
										peg$currPos++;
									} else {
										s5 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c267); }
									}
									if (s5 !== peg$FAILED) {
										if (peg$c266.test(input.charAt(peg$currPos))) {
											s6 = input.charAt(peg$currPos);
											peg$currPos++;
										} else {
											s6 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$c267); }
										}
										if (s6 !== peg$FAILED) {
											s5 = [s5, s6];
											s4 = s5;
										} else {
											peg$currPos = s4;
											s4 = peg$FAILED;
										}
									} else {
										peg$currPos = s4;
										s4 = peg$FAILED;
									}
									if (s4 !== peg$FAILED) {
										if (input.charCodeAt(peg$currPos) === 46) {
											s5 = peg$c268;
											peg$currPos++;
										} else {
											s5 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$c269); }
										}
										if (s5 !== peg$FAILED) {
											s6 = peg$currPos;
											if (peg$c266.test(input.charAt(peg$currPos))) {
												s7 = input.charAt(peg$currPos);
												peg$currPos++;
											} else {
												s7 = peg$FAILED;
												if (peg$silentFails === 0) { peg$fail(peg$c267); }
											}
											if (s7 !== peg$FAILED) {
												if (peg$c266.test(input.charAt(peg$currPos))) {
													s8 = input.charAt(peg$currPos);
													peg$currPos++;
												} else {
													s8 = peg$FAILED;
													if (peg$silentFails === 0) { peg$fail(peg$c267); }
												}
												if (s8 !== peg$FAILED) {
													s7 = [s7, s8];
													s6 = s7;
												} else {
													peg$currPos = s6;
													s6 = peg$FAILED;
												}
											} else {
												peg$currPos = s6;
												s6 = peg$FAILED;
											}
											if (s6 !== peg$FAILED) {
												s7 = peg$parsequotation_mark();
												if (s7 !== peg$FAILED) {
													peg$savedPos = s0;
													s1 = peg$c270(s2, s4, s6);
													s0 = s1;
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parseresult() {
						var s0, s1, s2, s3;

						s0 = peg$currPos;
						s1 = peg$parsequotation_mark();
						if (s1 !== peg$FAILED) {
							s2 = peg$parseinner_result();
							if (s2 !== peg$FAILED) {
								s3 = peg$parsequotation_mark();
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c271(s2);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parseinner_result() {
						var s0, s1;

						s0 = peg$currPos;
						if (input.substr(peg$currPos, 3) === peg$c272) {
							s1 = peg$c272;
							peg$currPos += 3;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c273); }
						}
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c274(s1);
						}
						s0 = s1;
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							if (input.substr(peg$currPos, 3) === peg$c275) {
								s1 = peg$c275;
								peg$currPos += 3;
							} else {
								s1 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c276); }
							}
							if (s1 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c271(s1);
							}
							s0 = s1;
							if (s0 === peg$FAILED) {
								s0 = peg$currPos;
								if (input.substr(peg$currPos, 3) === peg$c277) {
									s1 = peg$c277;
									peg$currPos += 3;
								} else {
									s1 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c278); }
								}
								if (s1 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c271(s1);
								}
								s0 = s1;
								if (s0 === peg$FAILED) {
									s0 = peg$currPos;
									if (input.substr(peg$currPos, 3) === peg$c279) {
										s1 = peg$c279;
										peg$currPos += 3;
									} else {
										s1 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c280); }
									}
									if (s1 !== peg$FAILED) {
										peg$savedPos = s0;
										s1 = peg$c271(s1);
									}
									s0 = s1;
									if (s0 === peg$FAILED) {
										s0 = peg$currPos;
										if (input.substr(peg$currPos, 7) === peg$c281) {
											s1 = peg$c281;
											peg$currPos += 7;
										} else {
											s1 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$c282); }
										}
										if (s1 !== peg$FAILED) {
											peg$savedPos = s0;
											s1 = peg$c271(s1);
										}
										s0 = s1;
										if (s0 === peg$FAILED) {
											s0 = peg$currPos;
											if (input.charCodeAt(peg$currPos) === 42) {
												s1 = peg$c283;
												peg$currPos++;
											} else {
												s1 = peg$FAILED;
												if (peg$silentFails === 0) { peg$fail(peg$c284); }
											}
											if (s1 !== peg$FAILED) {
												peg$savedPos = s0;
												s1 = peg$c271(s1);
											}
											s0 = s1;
										}
									}
								}
							}
						}

						return s0;
					}

					function peg$parseintegerOrDash() {
						var s0, s1, s2, s3;

						s0 = peg$parseintegerString();
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							s1 = peg$parsequotation_mark();
							if (s1 !== peg$FAILED) {
								if (input.charCodeAt(peg$currPos) === 45) {
									s2 = peg$c285;
									peg$currPos++;
								} else {
									s2 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c286); }
								}
								if (s2 !== peg$FAILED) {
									s3 = peg$parsequotation_mark();
									if (s3 !== peg$FAILED) {
										s1 = [s1, s2, s3];
										s0 = s1;
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						}

						return s0;
					}

					function peg$parseintegerString() {
						var s0, s1, s2, s3;

						s0 = peg$currPos;
						s1 = peg$parsequotation_mark();
						if (s1 !== peg$FAILED) {
							s2 = [];
							if (peg$c287.test(input.charAt(peg$currPos))) {
								s3 = input.charAt(peg$currPos);
								peg$currPos++;
							} else {
								s3 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c288); }
							}
							if (s3 !== peg$FAILED) {
								while (s3 !== peg$FAILED) {
									s2.push(s3);
									if (peg$c287.test(input.charAt(peg$currPos))) {
										s3 = input.charAt(peg$currPos);
										peg$currPos++;
									} else {
										s3 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c288); }
									}
								}
							} else {
								s2 = peg$FAILED;
							}
							if (s2 !== peg$FAILED) {
								s3 = peg$parsequotation_mark();
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c289(s2);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsepgn() {
						var s0, s1, s2;

						s0 = peg$currPos;
						s1 = peg$parsepgnStartWhite();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsepgnBlack();
							if (s2 === peg$FAILED) {
								s2 = null;
							}
							if (s2 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c290(s1, s2);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							s1 = peg$parsepgnStartBlack();
							if (s1 !== peg$FAILED) {
								s2 = peg$parsepgnWhite();
								if (s2 === peg$FAILED) {
									s2 = null;
								}
								if (s2 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c291(s1, s2);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
							if (s0 === peg$FAILED) {
								s0 = peg$currPos;
								s1 = peg$parsews();
								if (s1 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c292();
								}
								s0 = s1;
							}
						}

						return s0;
					}

					function peg$parsepgnStartWhite() {
						var s0, s1;

						s0 = peg$currPos;
						s1 = peg$parsepgnWhite();
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c293(s1);
						}
						s0 = s1;

						return s0;
					}

					function peg$parsepgnStartBlack() {
						var s0, s1;

						s0 = peg$currPos;
						s1 = peg$parsepgnBlack();
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c294(s1);
						}
						s0 = s1;

						return s0;
					}

					function peg$parsepgnWhite() {
						var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;

						s0 = peg$currPos;
						s1 = peg$parsews();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsecomments();
							if (s2 === peg$FAILED) {
								s2 = null;
							}
							if (s2 !== peg$FAILED) {
								s3 = peg$parsews();
								if (s3 !== peg$FAILED) {
									s4 = peg$parsemoveNumber();
									if (s4 === peg$FAILED) {
										s4 = null;
									}
									if (s4 !== peg$FAILED) {
										s5 = peg$parsews();
										if (s5 !== peg$FAILED) {
											s6 = peg$parsecomments();
											if (s6 === peg$FAILED) {
												s6 = null;
											}
											if (s6 !== peg$FAILED) {
												s7 = peg$parsews();
												if (s7 !== peg$FAILED) {
													s8 = peg$parsehalfMove();
													if (s8 !== peg$FAILED) {
														s9 = peg$parsews();
														if (s9 !== peg$FAILED) {
															s10 = peg$parsenags();
															if (s10 === peg$FAILED) {
																s10 = null;
															}
															if (s10 !== peg$FAILED) {
																s11 = peg$parsews();
																if (s11 !== peg$FAILED) {
																	s12 = peg$parsecomments();
																	if (s12 === peg$FAILED) {
																		s12 = null;
																	}
																	if (s12 !== peg$FAILED) {
																		s13 = peg$parsews();
																		if (s13 !== peg$FAILED) {
																			s14 = peg$parsecommentDiag();
																			if (s14 === peg$FAILED) {
																				s14 = null;
																			}
																			if (s14 !== peg$FAILED) {
																				s15 = peg$parsews();
																				if (s15 !== peg$FAILED) {
																					s16 = peg$parsevariationWhite();
																					if (s16 === peg$FAILED) {
																						s16 = null;
																					}
																					if (s16 !== peg$FAILED) {
																						s17 = peg$parsepgnBlack();
																						if (s17 === peg$FAILED) {
																							s17 = null;
																						}
																						if (s17 !== peg$FAILED) {
																							peg$savedPos = s0;
																							s1 = peg$c295(s2, s4, s6, s8, s10, s12, s14, s16, s17);
																							s0 = s1;
																						} else {
																							peg$currPos = s0;
																							s0 = peg$FAILED;
																						}
																					} else {
																						peg$currPos = s0;
																						s0 = peg$FAILED;
																					}
																				} else {
																					peg$currPos = s0;
																					s0 = peg$FAILED;
																				}
																			} else {
																				peg$currPos = s0;
																				s0 = peg$FAILED;
																			}
																		} else {
																			peg$currPos = s0;
																			s0 = peg$FAILED;
																		}
																	} else {
																		peg$currPos = s0;
																		s0 = peg$FAILED;
																	}
																} else {
																	peg$currPos = s0;
																	s0 = peg$FAILED;
																}
															} else {
																peg$currPos = s0;
																s0 = peg$FAILED;
															}
														} else {
															peg$currPos = s0;
															s0 = peg$FAILED;
														}
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
						if (s0 === peg$FAILED) {
							s0 = peg$parseendGame();
						}

						return s0;
					}

					function peg$parsepgnBlack() {
						var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;

						s0 = peg$currPos;
						s1 = peg$parsews();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsecomments();
							if (s2 === peg$FAILED) {
								s2 = null;
							}
							if (s2 !== peg$FAILED) {
								s3 = peg$parsews();
								if (s3 !== peg$FAILED) {
									s4 = peg$parsemoveNumber();
									if (s4 === peg$FAILED) {
										s4 = null;
									}
									if (s4 !== peg$FAILED) {
										s5 = peg$parsews();
										if (s5 !== peg$FAILED) {
											s6 = peg$parsecomments();
											if (s6 === peg$FAILED) {
												s6 = null;
											}
											if (s6 !== peg$FAILED) {
												s7 = peg$parsews();
												if (s7 !== peg$FAILED) {
													s8 = peg$parsehalfMove();
													if (s8 !== peg$FAILED) {
														s9 = peg$parsews();
														if (s9 !== peg$FAILED) {
															s10 = peg$parsenags();
															if (s10 === peg$FAILED) {
																s10 = null;
															}
															if (s10 !== peg$FAILED) {
																s11 = peg$parsews();
																if (s11 !== peg$FAILED) {
																	s12 = peg$parsecomments();
																	if (s12 === peg$FAILED) {
																		s12 = null;
																	}
																	if (s12 !== peg$FAILED) {
																		s13 = peg$parsews();
																		if (s13 !== peg$FAILED) {
																			s14 = peg$parsecommentDiag();
																			if (s14 === peg$FAILED) {
																				s14 = null;
																			}
																			if (s14 !== peg$FAILED) {
																				s15 = peg$parsews();
																				if (s15 !== peg$FAILED) {
																					s16 = peg$parsevariationBlack();
																					if (s16 === peg$FAILED) {
																						s16 = null;
																					}
																					if (s16 !== peg$FAILED) {
																						s17 = peg$parsepgnWhite();
																						if (s17 === peg$FAILED) {
																							s17 = null;
																						}
																						if (s17 !== peg$FAILED) {
																							peg$savedPos = s0;
																							s1 = peg$c296(s2, s4, s6, s8, s10, s12, s14, s16, s17);
																							s0 = s1;
																						} else {
																							peg$currPos = s0;
																							s0 = peg$FAILED;
																						}
																					} else {
																						peg$currPos = s0;
																						s0 = peg$FAILED;
																					}
																				} else {
																					peg$currPos = s0;
																					s0 = peg$FAILED;
																				}
																			} else {
																				peg$currPos = s0;
																				s0 = peg$FAILED;
																			}
																		} else {
																			peg$currPos = s0;
																			s0 = peg$FAILED;
																		}
																	} else {
																		peg$currPos = s0;
																		s0 = peg$FAILED;
																	}
																} else {
																	peg$currPos = s0;
																	s0 = peg$FAILED;
																}
															} else {
																peg$currPos = s0;
																s0 = peg$FAILED;
															}
														} else {
															peg$currPos = s0;
															s0 = peg$FAILED;
														}
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
						if (s0 === peg$FAILED) {
							s0 = peg$parseendGame();
						}

						return s0;
					}

					function peg$parseendGame() {
						var s0, s1;

						s0 = peg$currPos;
						if (input.substr(peg$currPos, 3) === peg$c275) {
							s1 = peg$c275;
							peg$currPos += 3;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c276); }
						}
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c297();
						}
						s0 = s1;
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							if (input.substr(peg$currPos, 3) === peg$c279) {
								s1 = peg$c279;
								peg$currPos += 3;
							} else {
								s1 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c280); }
							}
							if (s1 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c298();
							}
							s0 = s1;
							if (s0 === peg$FAILED) {
								s0 = peg$currPos;
								if (input.substr(peg$currPos, 3) === peg$c272) {
									s1 = peg$c272;
									peg$currPos += 3;
								} else {
									s1 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c273); }
								}
								if (s1 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c299();
								}
								s0 = s1;
								if (s0 === peg$FAILED) {
									s0 = peg$currPos;
									if (input.substr(peg$currPos, 3) === peg$c277) {
										s1 = peg$c277;
										peg$currPos += 3;
									} else {
										s1 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c278); }
									}
									if (s1 !== peg$FAILED) {
										peg$savedPos = s0;
										s1 = peg$c300();
									}
									s0 = s1;
									if (s0 === peg$FAILED) {
										s0 = peg$currPos;
										if (input.substr(peg$currPos, 7) === peg$c281) {
											s1 = peg$c281;
											peg$currPos += 7;
										} else {
											s1 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$c282); }
										}
										if (s1 !== peg$FAILED) {
											peg$savedPos = s0;
											s1 = peg$c301();
										}
										s0 = s1;
										if (s0 === peg$FAILED) {
											s0 = peg$currPos;
											if (input.charCodeAt(peg$currPos) === 42) {
												s1 = peg$c283;
												peg$currPos++;
											} else {
												s1 = peg$FAILED;
												if (peg$silentFails === 0) { peg$fail(peg$c284); }
											}
											if (s1 !== peg$FAILED) {
												peg$savedPos = s0;
												s1 = peg$c302();
											}
											s0 = s1;
										}
									}
								}
							}
						}

						return s0;
					}

					function peg$parsecomments() {
						var s0, s1, s2, s3, s4, s5;

						s0 = peg$currPos;
						s1 = peg$parsecomment();
						if (s1 !== peg$FAILED) {
							s2 = [];
							s3 = peg$currPos;
							s4 = peg$parsews();
							if (s4 !== peg$FAILED) {
								s5 = peg$parsecomment();
								if (s5 !== peg$FAILED) {
									s4 = [s4, s5];
									s3 = s4;
								} else {
									peg$currPos = s3;
									s3 = peg$FAILED;
								}
							} else {
								peg$currPos = s3;
								s3 = peg$FAILED;
							}
							while (s3 !== peg$FAILED) {
								s2.push(s3);
								s3 = peg$currPos;
								s4 = peg$parsews();
								if (s4 !== peg$FAILED) {
									s5 = peg$parsecomment();
									if (s5 !== peg$FAILED) {
										s4 = [s4, s5];
										s3 = s4;
									} else {
										peg$currPos = s3;
										s3 = peg$FAILED;
									}
								} else {
									peg$currPos = s3;
									s3 = peg$FAILED;
								}
							}
							if (s2 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c303(s1, s2);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecomment() {
						var s0, s1, s2, s3, s4;

						s0 = peg$currPos;
						s1 = peg$currPos;
						peg$silentFails++;
						s2 = peg$parsecommentDiag();
						peg$silentFails--;
						if (s2 === peg$FAILED) {
							s1 = void 0;
						} else {
							peg$currPos = s1;
							s1 = peg$FAILED;
						}
						if (s1 !== peg$FAILED) {
							s2 = peg$parsecl();
							if (s2 !== peg$FAILED) {
								s3 = peg$parsecommentText();
								if (s3 !== peg$FAILED) {
									s4 = peg$parsecr();
									if (s4 !== peg$FAILED) {
										peg$savedPos = s0;
										s1 = peg$c304(s3);
										s0 = s1;
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							s1 = peg$parsecommentEndOfLine();
							if (s1 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c304(s1);
							}
							s0 = s1;
						}

						return s0;
					}

					function peg$parsecommentEndOfLine() {
						var s0, s1, s2, s3;

						s0 = peg$currPos;
						s1 = peg$parsesemicolon();
						if (s1 !== peg$FAILED) {
							s2 = [];
							if (peg$c305.test(input.charAt(peg$currPos))) {
								s3 = input.charAt(peg$currPos);
								peg$currPos++;
							} else {
								s3 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c306); }
							}
							while (s3 !== peg$FAILED) {
								s2.push(s3);
								if (peg$c305.test(input.charAt(peg$currPos))) {
									s3 = input.charAt(peg$currPos);
									peg$currPos++;
								} else {
									s3 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c306); }
								}
							}
							if (s2 !== peg$FAILED) {
								s3 = peg$parseeol();
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c307(s2);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecommentText() {
						var s0, s1, s2;

						s0 = peg$currPos;
						s1 = [];
						if (peg$c308.test(input.charAt(peg$currPos))) {
							s2 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s2 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c309); }
						}
						if (s2 !== peg$FAILED) {
							while (s2 !== peg$FAILED) {
								s1.push(s2);
								if (peg$c308.test(input.charAt(peg$currPos))) {
									s2 = input.charAt(peg$currPos);
									peg$currPos++;
								} else {
									s2 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c309); }
								}
							}
						} else {
							s1 = peg$FAILED;
						}
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c307(s1);
						}
						s0 = s1;

						return s0;
					}

					function peg$parsecommentDiag() {
						var s0, s1, s2, s3, s4, s5, s6;

						s0 = peg$currPos;
						s1 = peg$parsecl();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsews();
							if (s2 !== peg$FAILED) {
								s3 = peg$parsecommentAnnotations();
								if (s3 !== peg$FAILED) {
									s4 = peg$parsews();
									if (s4 !== peg$FAILED) {
										s5 = peg$parsecommentText();
										if (s5 === peg$FAILED) {
											s5 = null;
										}
										if (s5 !== peg$FAILED) {
											s6 = peg$parsecr();
											if (s6 !== peg$FAILED) {
												peg$savedPos = s0;
												s1 = peg$c310(s3, s5);
												s0 = s1;
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecommentAnnotations() {
						var s0, s1, s2, s3, s4;

						s0 = peg$currPos;
						s1 = peg$parsecommentAnnotation();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsews();
							if (s2 !== peg$FAILED) {
								s3 = [];
								s4 = peg$parsecommentAnnotation();
								while (s4 !== peg$FAILED) {
									s3.push(s4);
									s4 = peg$parsecommentAnnotation();
								}
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c311(s1, s3);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecommentAnnotation() {
						var s0, s1;

						s0 = peg$currPos;
						s1 = peg$parsecommentAnnotationFields();
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c312(s1);
						}
						s0 = s1;
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							s1 = peg$parsecommentAnnotationArrows();
							if (s1 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c313(s1);
							}
							s0 = s1;
							if (s0 === peg$FAILED) {
								s0 = peg$currPos;
								s1 = peg$parsecommentAnnotationClock();
								if (s1 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c314(s1);
								}
								s0 = s1;
							}
						}

						return s0;
					}

					function peg$parsecommentAnnotationFields() {
						var s0, s1, s2, s3, s4, s5, s6, s7;

						s0 = peg$currPos;
						s1 = peg$parsebl();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsews();
							if (s2 !== peg$FAILED) {
								if (input.substr(peg$currPos, 4) === peg$c315) {
									s3 = peg$c315;
									peg$currPos += 4;
								} else {
									s3 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c316); }
								}
								if (s3 !== peg$FAILED) {
									s4 = peg$parsews();
									if (s4 !== peg$FAILED) {
										s5 = peg$parsecolorFields();
										if (s5 !== peg$FAILED) {
											s6 = peg$parsews();
											if (s6 !== peg$FAILED) {
												s7 = peg$parsebr();
												if (s7 !== peg$FAILED) {
													peg$savedPos = s0;
													s1 = peg$c317(s5);
													s0 = s1;
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecommentAnnotationArrows() {
						var s0, s1, s2, s3, s4, s5, s6, s7;

						s0 = peg$currPos;
						s1 = peg$parsebl();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsews();
							if (s2 !== peg$FAILED) {
								if (input.substr(peg$currPos, 4) === peg$c318) {
									s3 = peg$c318;
									peg$currPos += 4;
								} else {
									s3 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c319); }
								}
								if (s3 !== peg$FAILED) {
									s4 = peg$parsews();
									if (s4 !== peg$FAILED) {
										s5 = peg$parsecolorArrows();
										if (s5 !== peg$FAILED) {
											s6 = peg$parsews();
											if (s6 !== peg$FAILED) {
												s7 = peg$parsebr();
												if (s7 !== peg$FAILED) {
													peg$savedPos = s0;
													s1 = peg$c317(s5);
													s0 = s1;
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecolorFields() {
						var s0, s1, s2, s3, s4, s5, s6, s7;

						s0 = peg$currPos;
						s1 = peg$parsecolorField();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsews();
							if (s2 !== peg$FAILED) {
								s3 = [];
								s4 = peg$currPos;
								if (input.charCodeAt(peg$currPos) === 44) {
									s5 = peg$c320;
									peg$currPos++;
								} else {
									s5 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c321); }
								}
								if (s5 !== peg$FAILED) {
									s6 = peg$parsews();
									if (s6 !== peg$FAILED) {
										s7 = peg$parsecolorField();
										if (s7 !== peg$FAILED) {
											s5 = [s5, s6, s7];
											s4 = s5;
										} else {
											peg$currPos = s4;
											s4 = peg$FAILED;
										}
									} else {
										peg$currPos = s4;
										s4 = peg$FAILED;
									}
								} else {
									peg$currPos = s4;
									s4 = peg$FAILED;
								}
								while (s4 !== peg$FAILED) {
									s3.push(s4);
									s4 = peg$currPos;
									if (input.charCodeAt(peg$currPos) === 44) {
										s5 = peg$c320;
										peg$currPos++;
									} else {
										s5 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c321); }
									}
									if (s5 !== peg$FAILED) {
										s6 = peg$parsews();
										if (s6 !== peg$FAILED) {
											s7 = peg$parsecolorField();
											if (s7 !== peg$FAILED) {
												s5 = [s5, s6, s7];
												s4 = s5;
											} else {
												peg$currPos = s4;
												s4 = peg$FAILED;
											}
										} else {
											peg$currPos = s4;
											s4 = peg$FAILED;
										}
									} else {
										peg$currPos = s4;
										s4 = peg$FAILED;
									}
								}
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c322(s1, s3);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecolorField() {
						var s0, s1, s2;

						s0 = peg$currPos;
						s1 = peg$parsecolor();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsefield();
							if (s2 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c323(s1, s2);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecolorArrows() {
						var s0, s1, s2, s3, s4, s5, s6, s7;

						s0 = peg$currPos;
						s1 = peg$parsecolorArrow();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsews();
							if (s2 !== peg$FAILED) {
								s3 = [];
								s4 = peg$currPos;
								if (input.charCodeAt(peg$currPos) === 44) {
									s5 = peg$c320;
									peg$currPos++;
								} else {
									s5 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c321); }
								}
								if (s5 !== peg$FAILED) {
									s6 = peg$parsews();
									if (s6 !== peg$FAILED) {
										s7 = peg$parsecolorArrow();
										if (s7 !== peg$FAILED) {
											s5 = [s5, s6, s7];
											s4 = s5;
										} else {
											peg$currPos = s4;
											s4 = peg$FAILED;
										}
									} else {
										peg$currPos = s4;
										s4 = peg$FAILED;
									}
								} else {
									peg$currPos = s4;
									s4 = peg$FAILED;
								}
								while (s4 !== peg$FAILED) {
									s3.push(s4);
									s4 = peg$currPos;
									if (input.charCodeAt(peg$currPos) === 44) {
										s5 = peg$c320;
										peg$currPos++;
									} else {
										s5 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c321); }
									}
									if (s5 !== peg$FAILED) {
										s6 = peg$parsews();
										if (s6 !== peg$FAILED) {
											s7 = peg$parsecolorArrow();
											if (s7 !== peg$FAILED) {
												s5 = [s5, s6, s7];
												s4 = s5;
											} else {
												peg$currPos = s4;
												s4 = peg$FAILED;
											}
										} else {
											peg$currPos = s4;
											s4 = peg$FAILED;
										}
									} else {
										peg$currPos = s4;
										s4 = peg$FAILED;
									}
								}
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c322(s1, s3);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecolorArrow() {
						var s0, s1, s2, s3;

						s0 = peg$currPos;
						s1 = peg$parsecolor();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsefield();
							if (s2 !== peg$FAILED) {
								s3 = peg$parsefield();
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c324(s1, s2, s3);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecolor() {
						var s0, s1;

						s0 = peg$currPos;
						if (input.charCodeAt(peg$currPos) === 89) {
							s1 = peg$c325;
							peg$currPos++;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c326); }
						}
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c327();
						}
						s0 = s1;
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							if (input.charCodeAt(peg$currPos) === 71) {
								s1 = peg$c328;
								peg$currPos++;
							} else {
								s1 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c329); }
							}
							if (s1 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c330();
							}
							s0 = s1;
							if (s0 === peg$FAILED) {
								s0 = peg$currPos;
								if (input.charCodeAt(peg$currPos) === 82) {
									s1 = peg$c331;
									peg$currPos++;
								} else {
									s1 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c332); }
								}
								if (s1 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c333();
								}
								s0 = s1;
								if (s0 === peg$FAILED) {
									s0 = peg$currPos;
									if (input.charCodeAt(peg$currPos) === 66) {
										s1 = peg$c334;
										peg$currPos++;
									} else {
										s1 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c335); }
									}
									if (s1 !== peg$FAILED) {
										peg$savedPos = s0;
										s1 = peg$c336();
									}
									s0 = s1;
								}
							}
						}

						return s0;
					}

					function peg$parsefield() {
						var s0, s1, s2;

						s0 = peg$currPos;
						s1 = peg$parsecolumn();
						if (s1 !== peg$FAILED) {
							s2 = peg$parserow();
							if (s2 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c337(s1, s2);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsecl() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 123) {
							s0 = peg$c338;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c339); }
						}

						return s0;
					}

					function peg$parsecr() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 125) {
							s0 = peg$c340;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c341); }
						}

						return s0;
					}

					function peg$parsebl() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 91) {
							s0 = peg$c342;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c343); }
						}

						return s0;
					}

					function peg$parsebr() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 93) {
							s0 = peg$c344;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c345); }
						}

						return s0;
					}

					function peg$parsesemicolon() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 59) {
							s0 = peg$c346;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c347); }
						}

						return s0;
					}

					function peg$parsecommentAnnotationClock() {
						var s0, s1, s2, s3, s4, s5, s6, s7, s8;

						s0 = peg$currPos;
						s1 = peg$parsebl();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsews();
							if (s2 !== peg$FAILED) {
								if (input.charCodeAt(peg$currPos) === 37) {
									s3 = peg$c348;
									peg$currPos++;
								} else {
									s3 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c349); }
								}
								if (s3 !== peg$FAILED) {
									s4 = peg$parseclockCommand();
									if (s4 !== peg$FAILED) {
										s5 = peg$parsews();
										if (s5 !== peg$FAILED) {
											s6 = peg$parseclockValue();
											if (s6 !== peg$FAILED) {
												s7 = peg$parsews();
												if (s7 !== peg$FAILED) {
													s8 = peg$parsebr();
													if (s8 !== peg$FAILED) {
														peg$savedPos = s0;
														s1 = peg$c350(s4, s6);
														s0 = s1;
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parseclockCommand() {
						var s0, s1;

						s0 = peg$currPos;
						if (input.substr(peg$currPos, 3) === peg$c351) {
							s1 = peg$c351;
							peg$currPos += 3;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c352); }
						}
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c353();
						}
						s0 = s1;
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							if (input.substr(peg$currPos, 3) === peg$c354) {
								s1 = peg$c354;
								peg$currPos += 3;
							} else {
								s1 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c355); }
							}
							if (s1 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c356();
							}
							s0 = s1;
							if (s0 === peg$FAILED) {
								s0 = peg$currPos;
								if (input.substr(peg$currPos, 3) === peg$c357) {
									s1 = peg$c357;
									peg$currPos += 3;
								} else {
									s1 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c358); }
								}
								if (s1 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c359();
								}
								s0 = s1;
								if (s0 === peg$FAILED) {
									s0 = peg$currPos;
									if (input.substr(peg$currPos, 3) === peg$c360) {
										s1 = peg$c360;
										peg$currPos += 3;
									} else {
										s1 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c361); }
									}
									if (s1 !== peg$FAILED) {
										peg$savedPos = s0;
										s1 = peg$c362();
									}
									s0 = s1;
								}
							}
						}

						return s0;
					}

					function peg$parseclockValue() {
						var s0, s1, s2, s3, s4, s5, s6, s7, s8;

						s0 = peg$currPos;
						s1 = peg$parsedigit();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsedigit();
							if (s2 === peg$FAILED) {
								s2 = null;
							}
							if (s2 !== peg$FAILED) {
								if (input.charCodeAt(peg$currPos) === 58) {
									s3 = peg$c363;
									peg$currPos++;
								} else {
									s3 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c364); }
								}
								if (s3 !== peg$FAILED) {
									s4 = peg$parsedigit();
									if (s4 !== peg$FAILED) {
										s5 = peg$parsedigit();
										if (s5 !== peg$FAILED) {
											if (input.charCodeAt(peg$currPos) === 58) {
												s6 = peg$c363;
												peg$currPos++;
											} else {
												s6 = peg$FAILED;
												if (peg$silentFails === 0) { peg$fail(peg$c364); }
											}
											if (s6 !== peg$FAILED) {
												s7 = peg$parsedigit();
												if (s7 !== peg$FAILED) {
													s8 = peg$parsedigit();
													if (s8 !== peg$FAILED) {
														peg$savedPos = s0;
														s1 = peg$c365(s1, s2, s4, s5, s7, s8);
														s0 = s1;
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsedigit() {
						var s0, s1;

						s0 = peg$currPos;
						if (peg$c287.test(input.charAt(peg$currPos))) {
							s1 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c288); }
						}
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c366(s1);
						}
						s0 = s1;

						return s0;
					}

					function peg$parsevariationWhite() {
						var s0, s1, s2, s3, s4, s5;

						s0 = peg$currPos;
						s1 = peg$parsepl();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsepgnWhite();
							if (s2 !== peg$FAILED) {
								s3 = peg$parsepr();
								if (s3 !== peg$FAILED) {
									s4 = peg$parsews();
									if (s4 !== peg$FAILED) {
										s5 = peg$parsevariationWhite();
										if (s5 === peg$FAILED) {
											s5 = null;
										}
										if (s5 !== peg$FAILED) {
											peg$savedPos = s0;
											s1 = peg$c367(s2, s5);
											s0 = s1;
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsevariationBlack() {
						var s0, s1, s2, s3, s4, s5;

						s0 = peg$currPos;
						s1 = peg$parsepl();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsepgnStartBlack();
							if (s2 !== peg$FAILED) {
								s3 = peg$parsepr();
								if (s3 !== peg$FAILED) {
									s4 = peg$parsews();
									if (s4 !== peg$FAILED) {
										s5 = peg$parsevariationBlack();
										if (s5 === peg$FAILED) {
											s5 = null;
										}
										if (s5 !== peg$FAILED) {
											peg$savedPos = s0;
											s1 = peg$c367(s2, s5);
											s0 = s1;
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsepl() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 40) {
							s0 = peg$c368;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c369); }
						}

						return s0;
					}

					function peg$parsepr() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 41) {
							s0 = peg$c370;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c371); }
						}

						return s0;
					}

					function peg$parsemoveNumber() {
						var s0, s1, s2, s3;

						s0 = peg$currPos;
						s1 = peg$parseinteger();
						if (s1 !== peg$FAILED) {
							s2 = [];
							s3 = peg$parsedotOrWhitespace();
							while (s3 !== peg$FAILED) {
								s2.push(s3);
								s3 = peg$parsedotOrWhitespace();
							}
							if (s2 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c372(s1);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsedot() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 46) {
							s0 = peg$c268;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c269); }
						}

						return s0;
					}

					function peg$parseinteger() {
						var s0, s1, s2;

						peg$silentFails++;
						s0 = peg$currPos;
						s1 = [];
						if (peg$c287.test(input.charAt(peg$currPos))) {
							s2 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s2 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c288); }
						}
						if (s2 !== peg$FAILED) {
							while (s2 !== peg$FAILED) {
								s1.push(s2);
								if (peg$c287.test(input.charAt(peg$currPos))) {
									s2 = input.charAt(peg$currPos);
									peg$currPos++;
								} else {
									s2 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c288); }
								}
							}
						} else {
							s1 = peg$FAILED;
						}
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c289(s1);
						}
						s0 = s1;
						peg$silentFails--;
						if (s0 === peg$FAILED) {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c373); }
						}

						return s0;
					}

					function peg$parsewhiteSpace() {
						var s0, s1, s2;

						s0 = peg$currPos;
						s1 = [];
						if (input.charCodeAt(peg$currPos) === 32) {
							s2 = peg$c374;
							peg$currPos++;
						} else {
							s2 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c375); }
						}
						if (s2 !== peg$FAILED) {
							while (s2 !== peg$FAILED) {
								s1.push(s2);
								if (input.charCodeAt(peg$currPos) === 32) {
									s2 = peg$c374;
									peg$currPos++;
								} else {
									s2 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c375); }
								}
							}
						} else {
							s1 = peg$FAILED;
						}
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c376();
						}
						s0 = s1;

						return s0;
					}

					function peg$parsedotOrWhitespace() {
						var s0;

						s0 = peg$parsedot();
						if (s0 === peg$FAILED) {
							s0 = peg$parsewhiteSpace();
						}

						return s0;
					}

					function peg$parsehalfMove() {
						var s0, s1, s2, s3, s4, s5, s6, s7, s8;

						s0 = peg$currPos;
						s1 = peg$parsefigure();
						if (s1 === peg$FAILED) {
							s1 = null;
						}
						if (s1 !== peg$FAILED) {
							s2 = peg$currPos;
							peg$silentFails++;
							s3 = peg$parsecheckdisc();
							peg$silentFails--;
							if (s3 !== peg$FAILED) {
								peg$currPos = s2;
								s2 = void 0;
							} else {
								s2 = peg$FAILED;
							}
							if (s2 !== peg$FAILED) {
								s3 = peg$parsediscriminator();
								if (s3 !== peg$FAILED) {
									s4 = peg$parsestrike();
									if (s4 === peg$FAILED) {
										s4 = null;
									}
									if (s4 !== peg$FAILED) {
										s5 = peg$parsecolumn();
										if (s5 !== peg$FAILED) {
											s6 = peg$parserow();
											if (s6 !== peg$FAILED) {
												s7 = peg$parsepromotion();
												if (s7 === peg$FAILED) {
													s7 = null;
												}
												if (s7 !== peg$FAILED) {
													s8 = peg$parsecheck();
													if (s8 === peg$FAILED) {
														s8 = null;
													}
													if (s8 !== peg$FAILED) {
														peg$savedPos = s0;
														s1 = peg$c377(s1, s3, s4, s5, s6, s7, s8);
														s0 = s1;
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							s1 = peg$parsefigure();
							if (s1 === peg$FAILED) {
								s1 = null;
							}
							if (s1 !== peg$FAILED) {
								s2 = peg$parsecolumn();
								if (s2 !== peg$FAILED) {
									s3 = peg$parserow();
									if (s3 !== peg$FAILED) {
										s4 = peg$parsestrikeOrDash();
										if (s4 === peg$FAILED) {
											s4 = null;
										}
										if (s4 !== peg$FAILED) {
											s5 = peg$parsecolumn();
											if (s5 !== peg$FAILED) {
												s6 = peg$parserow();
												if (s6 !== peg$FAILED) {
													s7 = peg$parsepromotion();
													if (s7 === peg$FAILED) {
														s7 = null;
													}
													if (s7 !== peg$FAILED) {
														s8 = peg$parsecheck();
														if (s8 === peg$FAILED) {
															s8 = null;
														}
														if (s8 !== peg$FAILED) {
															peg$savedPos = s0;
															s1 = peg$c378(s1, s2, s3, s4, s5, s6, s7, s8);
															s0 = s1;
														} else {
															peg$currPos = s0;
															s0 = peg$FAILED;
														}
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
							if (s0 === peg$FAILED) {
								s0 = peg$currPos;
								s1 = peg$parsefigure();
								if (s1 === peg$FAILED) {
									s1 = null;
								}
								if (s1 !== peg$FAILED) {
									s2 = peg$parsestrike();
									if (s2 === peg$FAILED) {
										s2 = null;
									}
									if (s2 !== peg$FAILED) {
										s3 = peg$parsecolumn();
										if (s3 !== peg$FAILED) {
											s4 = peg$parserow();
											if (s4 !== peg$FAILED) {
												s5 = peg$parsepromotion();
												if (s5 === peg$FAILED) {
													s5 = null;
												}
												if (s5 !== peg$FAILED) {
													s6 = peg$parsecheck();
													if (s6 === peg$FAILED) {
														s6 = null;
													}
													if (s6 !== peg$FAILED) {
														peg$savedPos = s0;
														s1 = peg$c379(s1, s2, s3, s4, s5, s6);
														s0 = s1;
													} else {
														peg$currPos = s0;
														s0 = peg$FAILED;
													}
												} else {
													peg$currPos = s0;
													s0 = peg$FAILED;
												}
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
								if (s0 === peg$FAILED) {
									s0 = peg$currPos;
									if (input.substr(peg$currPos, 5) === peg$c380) {
										s1 = peg$c380;
										peg$currPos += 5;
									} else {
										s1 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c381); }
									}
									if (s1 !== peg$FAILED) {
										s2 = peg$parsecheck();
										if (s2 === peg$FAILED) {
											s2 = null;
										}
										if (s2 !== peg$FAILED) {
											peg$savedPos = s0;
											s1 = peg$c382(s2);
											s0 = s1;
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
									if (s0 === peg$FAILED) {
										s0 = peg$currPos;
										if (input.substr(peg$currPos, 3) === peg$c383) {
											s1 = peg$c383;
											peg$currPos += 3;
										} else {
											s1 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$c384); }
										}
										if (s1 !== peg$FAILED) {
											s2 = peg$parsecheck();
											if (s2 === peg$FAILED) {
												s2 = null;
											}
											if (s2 !== peg$FAILED) {
												peg$savedPos = s0;
												s1 = peg$c385(s2);
												s0 = s1;
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									}
								}
							}
						}

						return s0;
					}

					function peg$parsecheck() {
						var s0, s1, s2, s3;

						s0 = peg$currPos;
						s1 = peg$currPos;
						s2 = peg$currPos;
						peg$silentFails++;
						if (input.substr(peg$currPos, 2) === peg$c386) {
							s3 = peg$c386;
							peg$currPos += 2;
						} else {
							s3 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c387); }
						}
						peg$silentFails--;
						if (s3 === peg$FAILED) {
							s2 = void 0;
						} else {
							peg$currPos = s2;
							s2 = peg$FAILED;
						}
						if (s2 !== peg$FAILED) {
							if (input.charCodeAt(peg$currPos) === 43) {
								s3 = peg$c388;
								peg$currPos++;
							} else {
								s3 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c389); }
							}
							if (s3 !== peg$FAILED) {
								s2 = [s2, s3];
								s1 = s2;
							} else {
								peg$currPos = s1;
								s1 = peg$FAILED;
							}
						} else {
							peg$currPos = s1;
							s1 = peg$FAILED;
						}
						if (s1 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c390(s1);
						}
						s0 = s1;
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							s1 = peg$currPos;
							s2 = peg$currPos;
							peg$silentFails++;
							if (input.substr(peg$currPos, 3) === peg$c391) {
								s3 = peg$c391;
								peg$currPos += 3;
							} else {
								s3 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c392); }
							}
							peg$silentFails--;
							if (s3 === peg$FAILED) {
								s2 = void 0;
							} else {
								peg$currPos = s2;
								s2 = peg$FAILED;
							}
							if (s2 !== peg$FAILED) {
								if (input.charCodeAt(peg$currPos) === 35) {
									s3 = peg$c393;
									peg$currPos++;
								} else {
									s3 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c394); }
								}
								if (s3 !== peg$FAILED) {
									s2 = [s2, s3];
									s1 = s2;
								} else {
									peg$currPos = s1;
									s1 = peg$FAILED;
								}
							} else {
								peg$currPos = s1;
								s1 = peg$FAILED;
							}
							if (s1 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c390(s1);
							}
							s0 = s1;
						}

						return s0;
					}

					function peg$parsepromotion() {
						var s0, s1, s2;

						s0 = peg$currPos;
						if (input.charCodeAt(peg$currPos) === 61) {
							s1 = peg$c395;
							peg$currPos++;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c396); }
						}
						if (s1 !== peg$FAILED) {
							s2 = peg$parsepromFigure();
							if (s2 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c397(s2);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsenags() {
						var s0, s1, s2, s3;

						s0 = peg$currPos;
						s1 = peg$parsenag();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsews();
							if (s2 !== peg$FAILED) {
								s3 = peg$parsenags();
								if (s3 === peg$FAILED) {
									s3 = null;
								}
								if (s3 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c398(s1, s3);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsenag() {
						var s0, s1, s2;

						s0 = peg$currPos;
						if (input.charCodeAt(peg$currPos) === 36) {
							s1 = peg$c399;
							peg$currPos++;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c400); }
						}
						if (s1 !== peg$FAILED) {
							s2 = peg$parseinteger();
							if (s2 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c401(s2);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							if (input.substr(peg$currPos, 2) === peg$c402) {
								s1 = peg$c402;
								peg$currPos += 2;
							} else {
								s1 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c403); }
							}
							if (s1 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c404();
							}
							s0 = s1;
							if (s0 === peg$FAILED) {
								s0 = peg$currPos;
								if (input.substr(peg$currPos, 2) === peg$c405) {
									s1 = peg$c405;
									peg$currPos += 2;
								} else {
									s1 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$c406); }
								}
								if (s1 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c407();
								}
								s0 = s1;
								if (s0 === peg$FAILED) {
									s0 = peg$currPos;
									if (input.substr(peg$currPos, 2) === peg$c408) {
										s1 = peg$c408;
										peg$currPos += 2;
									} else {
										s1 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$c409); }
									}
									if (s1 !== peg$FAILED) {
										peg$savedPos = s0;
										s1 = peg$c410();
									}
									s0 = s1;
									if (s0 === peg$FAILED) {
										s0 = peg$currPos;
										if (input.substr(peg$currPos, 2) === peg$c411) {
											s1 = peg$c411;
											peg$currPos += 2;
										} else {
											s1 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$c412); }
										}
										if (s1 !== peg$FAILED) {
											peg$savedPos = s0;
											s1 = peg$c413();
										}
										s0 = s1;
										if (s0 === peg$FAILED) {
											s0 = peg$currPos;
											if (input.charCodeAt(peg$currPos) === 33) {
												s1 = peg$c414;
												peg$currPos++;
											} else {
												s1 = peg$FAILED;
												if (peg$silentFails === 0) { peg$fail(peg$c415); }
											}
											if (s1 !== peg$FAILED) {
												peg$savedPos = s0;
												s1 = peg$c416();
											}
											s0 = s1;
											if (s0 === peg$FAILED) {
												s0 = peg$currPos;
												if (input.charCodeAt(peg$currPos) === 63) {
													s1 = peg$c417;
													peg$currPos++;
												} else {
													s1 = peg$FAILED;
													if (peg$silentFails === 0) { peg$fail(peg$c418); }
												}
												if (s1 !== peg$FAILED) {
													peg$savedPos = s0;
													s1 = peg$c419();
												}
												s0 = s1;
												if (s0 === peg$FAILED) {
													s0 = peg$currPos;
													if (input.charCodeAt(peg$currPos) === 8252) {
														s1 = peg$c420;
														peg$currPos++;
													} else {
														s1 = peg$FAILED;
														if (peg$silentFails === 0) { peg$fail(peg$c421); }
													}
													if (s1 !== peg$FAILED) {
														peg$savedPos = s0;
														s1 = peg$c404();
													}
													s0 = s1;
													if (s0 === peg$FAILED) {
														s0 = peg$currPos;
														if (input.charCodeAt(peg$currPos) === 8263) {
															s1 = peg$c422;
															peg$currPos++;
														} else {
															s1 = peg$FAILED;
															if (peg$silentFails === 0) { peg$fail(peg$c423); }
														}
														if (s1 !== peg$FAILED) {
															peg$savedPos = s0;
															s1 = peg$c407();
														}
														s0 = s1;
														if (s0 === peg$FAILED) {
															s0 = peg$currPos;
															if (input.charCodeAt(peg$currPos) === 8265) {
																s1 = peg$c424;
																peg$currPos++;
															} else {
																s1 = peg$FAILED;
																if (peg$silentFails === 0) { peg$fail(peg$c425); }
															}
															if (s1 !== peg$FAILED) {
																peg$savedPos = s0;
																s1 = peg$c410();
															}
															s0 = s1;
															if (s0 === peg$FAILED) {
																s0 = peg$currPos;
																if (input.charCodeAt(peg$currPos) === 8264) {
																	s1 = peg$c426;
																	peg$currPos++;
																} else {
																	s1 = peg$FAILED;
																	if (peg$silentFails === 0) { peg$fail(peg$c427); }
																}
																if (s1 !== peg$FAILED) {
																	peg$savedPos = s0;
																	s1 = peg$c413();
																}
																s0 = s1;
																if (s0 === peg$FAILED) {
																	s0 = peg$currPos;
																	if (input.charCodeAt(peg$currPos) === 9633) {
																		s1 = peg$c428;
																		peg$currPos++;
																	} else {
																		s1 = peg$FAILED;
																		if (peg$silentFails === 0) { peg$fail(peg$c429); }
																	}
																	if (s1 !== peg$FAILED) {
																		peg$savedPos = s0;
																		s1 = peg$c430();
																	}
																	s0 = s1;
																	if (s0 === peg$FAILED) {
																		s0 = peg$currPos;
																		if (input.charCodeAt(peg$currPos) === 61) {
																			s1 = peg$c395;
																			peg$currPos++;
																		} else {
																			s1 = peg$FAILED;
																			if (peg$silentFails === 0) { peg$fail(peg$c396); }
																		}
																		if (s1 !== peg$FAILED) {
																			peg$savedPos = s0;
																			s1 = peg$c431();
																		}
																		s0 = s1;
																		if (s0 === peg$FAILED) {
																			s0 = peg$currPos;
																			if (input.charCodeAt(peg$currPos) === 8734) {
																				s1 = peg$c432;
																				peg$currPos++;
																			} else {
																				s1 = peg$FAILED;
																				if (peg$silentFails === 0) { peg$fail(peg$c433); }
																			}
																			if (s1 !== peg$FAILED) {
																				peg$savedPos = s0;
																				s1 = peg$c434();
																			}
																			s0 = s1;
																			if (s0 === peg$FAILED) {
																				s0 = peg$currPos;
																				if (input.charCodeAt(peg$currPos) === 10866) {
																					s1 = peg$c435;
																					peg$currPos++;
																				} else {
																					s1 = peg$FAILED;
																					if (peg$silentFails === 0) { peg$fail(peg$c436); }
																				}
																				if (s1 !== peg$FAILED) {
																					peg$savedPos = s0;
																					s1 = peg$c437();
																				}
																				s0 = s1;
																				if (s0 === peg$FAILED) {
																					s0 = peg$currPos;
																					if (input.charCodeAt(peg$currPos) === 10865) {
																						s1 = peg$c438;
																						peg$currPos++;
																					} else {
																						s1 = peg$FAILED;
																						if (peg$silentFails === 0) { peg$fail(peg$c439); }
																					}
																					if (s1 !== peg$FAILED) {
																						peg$savedPos = s0;
																						s1 = peg$c440();
																					}
																					s0 = s1;
																					if (s0 === peg$FAILED) {
																						s0 = peg$currPos;
																						if (input.charCodeAt(peg$currPos) === 177) {
																							s1 = peg$c441;
																							peg$currPos++;
																						} else {
																							s1 = peg$FAILED;
																							if (peg$silentFails === 0) { peg$fail(peg$c442); }
																						}
																						if (s1 !== peg$FAILED) {
																							peg$savedPos = s0;
																							s1 = peg$c443();
																						}
																						s0 = s1;
																						if (s0 === peg$FAILED) {
																							s0 = peg$currPos;
																							if (input.charCodeAt(peg$currPos) === 8723) {
																								s1 = peg$c444;
																								peg$currPos++;
																							} else {
																								s1 = peg$FAILED;
																								if (peg$silentFails === 0) { peg$fail(peg$c445); }
																							}
																							if (s1 !== peg$FAILED) {
																								peg$savedPos = s0;
																								s1 = peg$c446();
																							}
																							s0 = s1;
																							if (s0 === peg$FAILED) {
																								s0 = peg$currPos;
																								if (input.substr(peg$currPos, 2) === peg$c386) {
																									s1 = peg$c386;
																									peg$currPos += 2;
																								} else {
																									s1 = peg$FAILED;
																									if (peg$silentFails === 0) { peg$fail(peg$c387); }
																								}
																								if (s1 !== peg$FAILED) {
																									peg$savedPos = s0;
																									s1 = peg$c447();
																								}
																								s0 = s1;
																								if (s0 === peg$FAILED) {
																									s0 = peg$currPos;
																									if (input.substr(peg$currPos, 2) === peg$c448) {
																										s1 = peg$c448;
																										peg$currPos += 2;
																									} else {
																										s1 = peg$FAILED;
																										if (peg$silentFails === 0) { peg$fail(peg$c449); }
																									}
																									if (s1 !== peg$FAILED) {
																										peg$savedPos = s0;
																										s1 = peg$c450();
																									}
																									s0 = s1;
																									if (s0 === peg$FAILED) {
																										s0 = peg$currPos;
																										if (input.charCodeAt(peg$currPos) === 10752) {
																											s1 = peg$c451;
																											peg$currPos++;
																										} else {
																											s1 = peg$FAILED;
																											if (peg$silentFails === 0) { peg$fail(peg$c452); }
																										}
																										if (s1 !== peg$FAILED) {
																											peg$savedPos = s0;
																											s1 = peg$c453();
																										}
																										s0 = s1;
																										if (s0 === peg$FAILED) {
																											s0 = peg$currPos;
																											if (input.charCodeAt(peg$currPos) === 10227) {
																												s1 = peg$c454;
																												peg$currPos++;
																											} else {
																												s1 = peg$FAILED;
																												if (peg$silentFails === 0) { peg$fail(peg$c455); }
																											}
																											if (s1 !== peg$FAILED) {
																												peg$savedPos = s0;
																												s1 = peg$c456();
																											}
																											s0 = s1;
																											if (s0 === peg$FAILED) {
																												s0 = peg$currPos;
																												if (input.charCodeAt(peg$currPos) === 8594) {
																													s1 = peg$c457;
																													peg$currPos++;
																												} else {
																													s1 = peg$FAILED;
																													if (peg$silentFails === 0) { peg$fail(peg$c458); }
																												}
																												if (s1 !== peg$FAILED) {
																													peg$savedPos = s0;
																													s1 = peg$c459();
																												}
																												s0 = s1;
																												if (s0 === peg$FAILED) {
																													s0 = peg$currPos;
																													if (input.charCodeAt(peg$currPos) === 8593) {
																														s1 = peg$c460;
																														peg$currPos++;
																													} else {
																														s1 = peg$FAILED;
																														if (peg$silentFails === 0) { peg$fail(peg$c461); }
																													}
																													if (s1 !== peg$FAILED) {
																														peg$savedPos = s0;
																														s1 = peg$c462();
																													}
																													s0 = s1;
																													if (s0 === peg$FAILED) {
																														s0 = peg$currPos;
																														if (input.charCodeAt(peg$currPos) === 8646) {
																															s1 = peg$c463;
																															peg$currPos++;
																														} else {
																															s1 = peg$FAILED;
																															if (peg$silentFails === 0) { peg$fail(peg$c464); }
																														}
																														if (s1 !== peg$FAILED) {
																															peg$savedPos = s0;
																															s1 = peg$c465();
																														}
																														s0 = s1;
																														if (s0 === peg$FAILED) {
																															s0 = peg$currPos;
																															if (input.charCodeAt(peg$currPos) === 68) {
																																s1 = peg$c466;
																																peg$currPos++;
																															} else {
																																s1 = peg$FAILED;
																																if (peg$silentFails === 0) { peg$fail(peg$c467); }
																															}
																															if (s1 !== peg$FAILED) {
																																peg$savedPos = s0;
																																s1 = peg$c468();
																															}
																															s0 = s1;
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}

						return s0;
					}

					function peg$parsediscriminator() {
						var s0;

						s0 = peg$parsecolumn();
						if (s0 === peg$FAILED) {
							s0 = peg$parserow();
						}

						return s0;
					}

					function peg$parsecheckdisc() {
						var s0, s1, s2, s3, s4;

						s0 = peg$currPos;
						s1 = peg$parsediscriminator();
						if (s1 !== peg$FAILED) {
							s2 = peg$parsestrike();
							if (s2 === peg$FAILED) {
								s2 = null;
							}
							if (s2 !== peg$FAILED) {
								s3 = peg$parsecolumn();
								if (s3 !== peg$FAILED) {
									s4 = peg$parserow();
									if (s4 !== peg$FAILED) {
										s1 = [s1, s2, s3, s4];
										s0 = s1;
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}

						return s0;
					}

					function peg$parsefigure() {
						var s0;

						if (peg$c469.test(input.charAt(peg$currPos))) {
							s0 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c470); }
						}

						return s0;
					}

					function peg$parsepromFigure() {
						var s0;

						if (peg$c471.test(input.charAt(peg$currPos))) {
							s0 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c472); }
						}

						return s0;
					}

					function peg$parsecolumn() {
						var s0;

						if (peg$c473.test(input.charAt(peg$currPos))) {
							s0 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c474); }
						}

						return s0;
					}

					function peg$parserow() {
						var s0;

						if (peg$c475.test(input.charAt(peg$currPos))) {
							s0 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c476); }
						}

						return s0;
					}

					function peg$parsestrike() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 120) {
							s0 = peg$c477;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c478); }
						}

						return s0;
					}

					function peg$parsestrikeOrDash() {
						var s0;

						if (input.charCodeAt(peg$currPos) === 120) {
							s0 = peg$c477;
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c478); }
						}
						if (s0 === peg$FAILED) {
							if (input.charCodeAt(peg$currPos) === 45) {
								s0 = peg$c285;
								peg$currPos++;
							} else {
								s0 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c286); }
							}
						}

						return s0;
					}


					function makeInteger(o) {
						return parseInt(o.join(""), 10);
					}


					peg$result = peg$startRuleFunction();

					if (peg$result !== peg$FAILED && peg$currPos === input.length) {
						return peg$result;
					} else {
						if (peg$result !== peg$FAILED && peg$currPos < input.length) {
							peg$fail(peg$endExpectation());
						}

						throw peg$buildStructuredError(
							peg$maxFailExpected,
							peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
							peg$maxFailPos < input.length
								? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
								: peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
						);
					}
				}

				module.exports = {
					SyntaxError: peg$SyntaxError,
					parse: peg$parse
				};

			}, {}], 2: [function (require, module, exports) {
				const parser = require('./pgn-parser.js')
				window.parsePgn = parser.parse
			}, { "./pgn-parser.js": 3 }], 3: [function (require, module, exports) {
				const parser = require('./_pgn-parser.js')

				/**
				 * Patches the original function, to avoid empty games. May include additional functionality
				 * for understanding parse errors later.
				 */
				const parse = function (input, options) {
					// Had to trim the grammar to allow no whitespace after a game, this is consumed only when read many games
					// Therefore the strings are trimmed here.
					if (!options || (options.startRule === 'pgn') || (options.startRule === 'game')) {
						input = input.trim()
					}
					let result = parser.parse(input, options)
					if (options && (options.startRule === 'games')) {
						// result should be an array of games. Check the last game, if it is empty, and remove it then
						if (!Array.isArray(result)) return result
						if (result.length === 0) return result
						let last = result.pop()
						if ((Object.keys(last.tags).length > 0) || (last.moves.length > 0)) {
							result.push(last)
						}
						return result
					}
					return result
				}

				module.exports = {
					SyntaxError: parser.SyntaxError,
					parse: parse
				};

			}, { "./_pgn-parser.js": 1 }]
		}, {}, [2]);

	</script>

	<script>
		/*! chessboard.js v1.0.0 | (c) 2019 Chris Oakman | MIT License chessboardjs.com/license */
		!function () { "use strict"; var z = window.jQuery, F = "abcdefgh".split(""), r = 20, A = "…", W = "1.8.3", e = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR", G = pe(e), n = 200, t = 200, o = 60, a = 30, i = 100, H = {}; function V(e, r, n) { function t() { o = 0, a && (a = !1, s()) } var o = 0, a = !1, i = [], s = function () { o = window.setTimeout(t, r), e.apply(n, i) }; return function (e) { i = arguments, o ? a = !0 : s() } } function Z() { return "xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx".replace(/x/g, function (e) { return (16 * Math.random() | 0).toString(16) }) } function _(e) { return JSON.parse(JSON.stringify(e)) } function s(e) { var r = e.split("."); return { major: parseInt(r[0], 10), minor: parseInt(r[1], 10), patch: parseInt(r[2], 10) } } function ee(e, r) { for (var n in r) if (r.hasOwnProperty(n)) for (var t = "{" + n + "}", o = r[n]; -1 !== e.indexOf(t);)e = e.replace(t, o); return e } function re(e) { return "string" == typeof e } function ne(e) { return "function" == typeof e } function p(e) { return "number" == typeof e && isFinite(e) && Math.floor(e) === e } function c(e) { return "fast" === e || "slow" === e || !!p(e) && 0 <= e } function te(e) { if (!re(e)) return !1; var r = e.split("-"); return 2 === r.length && (oe(r[0]) && oe(r[1])) } function oe(e) { return re(e) && -1 !== e.search(/^[a-h][1-8]$/) } function u(e) { return re(e) && -1 !== e.search(/^[bw][KQRNBP]$/) } function ae(e) { if (!re(e)) return !1; var r = (e = function (e) { return e.replace(/8/g, "11111111").replace(/7/g, "1111111").replace(/6/g, "111111").replace(/5/g, "11111").replace(/4/g, "1111").replace(/3/g, "111").replace(/2/g, "11") }(e = e.replace(/ .+$/, ""))).split("/"); if (8 !== r.length) return !1; for (var n = 0; n < 8; n++)if (8 !== r[n].length || -1 !== r[n].search(/[^kqrnbpKQRNBP1]/)) return !1; return !0 } function ie(e) { if (!z.isPlainObject(e)) return !1; for (var r in e) if (e.hasOwnProperty(r) && (!oe(r) || !u(e[r]))) return !1; return !0 } function se() { return typeof window.$ && z.fn && z.fn.jquery && function (e, r) { e = s(e), r = s(r); var n = 1e5 * e.major * 1e5 + 1e5 * e.minor + e.patch; return 1e5 * r.major * 1e5 + 1e5 * r.minor + r.patch <= n }(z.fn.jquery, W) } function pe(e) { if (!ae(e)) return !1; for (var r, n = (e = e.replace(/ .+$/, "")).split("/"), t = {}, o = 8, a = 0; a < 8; a++) { for (var i = n[a].split(""), s = 0, p = 0; p < i.length; p++) { if (-1 !== i[p].search(/[1-8]/)) s += parseInt(i[p], 10); else t[F[s] + o] = (r = i[p]).toLowerCase() === r ? "b" + r.toUpperCase() : "w" + r.toUpperCase(), s += 1 } o -= 1 } return t } function ce(e) { if (!ie(e)) return !1; for (var r, n, t = "", o = 8, a = 0; a < 8; a++) { for (var i = 0; i < 8; i++) { var s = F[i] + o; e.hasOwnProperty(s) ? t += (r = e[s], n = void 0, "w" === (n = r.split(""))[0] ? n[1].toUpperCase() : n[1].toLowerCase()) : t += "1" } 7 !== a && (t += "/"), o -= 1 } return t = function (e) { return e.replace(/11111111/g, "8").replace(/1111111/g, "7").replace(/111111/g, "6").replace(/11111/g, "5").replace(/1111/g, "4").replace(/111/g, "3").replace(/11/g, "2") }(t) } function ue(e, r, n) { for (var t = function (e) { for (var r = [], n = 0; n < 8; n++)for (var t = 0; t < 8; t++) { var o = F[n] + (t + 1); e !== o && r.push({ square: o, distance: (a = e, i = o, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, s = a.split(""), p = F.indexOf(s[0]) + 1, c = parseInt(s[1], 10), u = i.split(""), f = F.indexOf(u[0]) + 1, d = parseInt(u[1], 10), h = Math.abs(p - f), l = Math.abs(c - d), l <= h ? h : l) }) } var a, i, s, p, c, u, f, d, h, l; r.sort(function (e, r) { return e.distance - r.distance }); var v = []; for (n = 0; n < r.length; n++)v.push(r[n].square); return v }(n), o = 0; o < t.length; o++) { var a = t[o]; if (e.hasOwnProperty(a) && e[a] === r) return a } return !1 } function fe(e) { return "black" !== e.orientation && (e.orientation = "white"), !1 !== e.showNotation && (e.showNotation = !0), !0 !== e.draggable && (e.draggable = !1), "trash" !== e.dropOffBoard && (e.dropOffBoard = "snapback"), !0 !== e.sparePieces && (e.sparePieces = !1), e.sparePieces && (e.draggable = !0), e.hasOwnProperty("pieceTheme") && (re(e.pieceTheme) || ne(e.pieceTheme)) || (e.pieceTheme = "_{piece}.svg"), c(e.appearSpeed) || (e.appearSpeed = n), c(e.moveSpeed) || (e.moveSpeed = t), c(e.snapbackSpeed) || (e.snapbackSpeed = o), c(e.snapSpeed) || (e.snapSpeed = a), c(e.trashSpeed) || (e.trashSpeed = i), function (e) { return p(e) && 1 <= e }(e.dragThrottleRate) || (e.dragThrottleRate = r), e } H.alpha = "alpha-d2270", H.black = "black-3c85d", H.board = "board-b72b1", H.chessboard = "chessboard-63f37", H.clearfix = "clearfix-7da63", H.highlight1 = "highlight1-32417", H.highlight2 = "highlight2-9c5d2", H.notation = "notation-322f9", H.numeric = "numeric-fc462", H.piece = "piece-417db", H.row = "row-5277c", H.sparePieces = "spare-pieces-7492f", H.sparePiecesBottom = "spare-pieces-bottom-ae20f", H.sparePiecesTop = "spare-pieces-top-4028b", H.square = "square-55d63", H.white = "white-1e1d7", window.Chessboard = function (e, f) { if (!function () { if (se()) return !0; var e = "Chessboard Error 1005: Unable to find a valid version of jQuery. Please include jQuery " + W + " or higher on the page\n\nExiting" + A; return window.alert(e), !1 }()) return null; var n = function (e) { if ("" === e) { var r = "Chessboard Error 1001: The first argument to Chessboard() cannot be an empty string.\n\nExiting" + A; return window.alert(r), !1 } re(e) && "#" !== e.charAt(0) && (e = "#" + e); var n = z(e); if (1 === n.length) return n; var t = "Chessboard Error 1003: The first argument to Chessboard() must be the ID of a DOM node, an ID query selector, or a single DOM node.\n\nExiting" + A; return window.alert(t), !1 }(e); if (!n) return null; f = fe(f = function (e) { return "start" === e ? e = { position: _(G) } : ae(e) ? e = { position: pe(e) } : ie(e) && (e = { position: _(e) }), z.isPlainObject(e) || (e = {}), e }(f)); var r = null, a = null, t = null, o = null, i = {}, s = 2, p = "white", c = {}, u = null, d = null, h = null, l = !1, v = {}, g = {}, w = {}, b = 16; function m(e, r, n) { if (!0 === f.hasOwnProperty("showErrors") && !1 !== f.showErrors) { var t = "Chessboard Error " + e + ": " + r; return "console" === f.showErrors && "object" == typeof console && "function" == typeof console.log ? (console.log(t), void (2 <= arguments.length && console.log(n))) : "alert" === f.showErrors ? (n && (t += "\n\n" + JSON.stringify(n)), void window.alert(t)) : void (ne(f.showErrors) && f.showErrors(e, r, n)) } } function P(e) { return ne(f.pieceTheme) ? f.pieceTheme(e) : re(f.pieceTheme) ? ee(f.pieceTheme, { piece: e }) : (m(8272, "Unable to build image source for config.pieceTheme."), "") } function y(e, r, n) { var t = '<img src="' + P(e) + '" '; return re(n) && "" !== n && (t += 'id="' + n + '" '), t += 'alt="" class="{piece}" data-piece="' + e + '" style="width:' + b + "px;height:" + b + "px;", r && (t += "display:none;"), ee(t += '" />', H) } function x(e) { var r = ["wK", "wQ", "wR", "wB", "wN", "wP"]; "black" === e && (r = ["bK", "bQ", "bR", "bB", "bN", "bP"]); for (var n = "", t = 0; t < r.length; t++)n += y(r[t], !1, v[r[t]]); return n } function O(e, r, n, t) { var o = z("#" + g[e]), a = o.offset(), i = z("#" + g[r]), s = i.offset(), p = Z(); z("body").append(y(n, !0, p)); var c = z("#" + p); c.css({ display: "", position: "absolute", top: a.top, left: a.left }), o.find("." + H.piece).remove(); var u = { duration: f.moveSpeed, complete: function () { i.append(y(n)), c.remove(), ne(t) && t() } }; c.animate(s, u) } function S(e, r, n) { var t = z("#" + v[e]).offset(), o = z("#" + g[r]), a = o.offset(), i = Z(); z("body").append(y(e, !0, i)); var s = z("#" + i); s.css({ display: "", position: "absolute", left: t.left, top: t.top }); var p = { duration: f.moveSpeed, complete: function () { o.find("." + H.piece).remove(), o.append(y(e)), s.remove(), ne(n) && n() } }; s.animate(a, p) } function T() { for (var e in r.find("." + H.piece).remove(), c) c.hasOwnProperty(e) && z("#" + g[e]).append(y(c[e])) } function q() { r.html(function (e) { "black" !== e && (e = "white"); var r = "", n = _(F), t = 8; "black" === e && (n.reverse(), t = 1); for (var o = "white", a = 0; a < 8; a++) { r += '<div class="{row}">'; for (var i = 0; i < 8; i++) { var s = n[i] + t; r += '<div class="{square} ' + H[o] + " square-" + s + '" style="width:' + b + "px;height:" + b + 'px;" id="' + g[s] + '" data-square="' + s + '">', f.showNotation && (("white" === e && 1 === t || "black" === e && 8 === t) && (r += '<div class="{notation} {alpha}">' + n[i] + "</div>"), 0 === i && (r += '<div class="{notation} {numeric}">' + t + "</div>")), r += "</div>", o = "white" === o ? "black" : "white" } r += '<div class="{clearfix}"></div></div>', o = "white" === o ? "black" : "white", "white" === e ? t -= 1 : t += 1 } return ee(r, H) }(p, f.showNotation)), T(), f.sparePieces && ("white" === p ? (t.html(x("black")), o.html(x("white"))) : (t.html(x("white")), o.html(x("black")))) } function k(e) { var r = _(c), n = _(e); ce(r) !== ce(n) && (ne(f.onChange) && f.onChange(r, n), c = e) } function E(e, r) { for (var n in w) if (w.hasOwnProperty(n)) { var t = w[n]; if (e >= t.left && e < t.left + b && r >= t.top && r < t.top + b) return n } return "offboard" } function C() { r.find("." + H.square).removeClass(H.highlight1 + " " + H.highlight2) } function B() { C(); var e = _(c); delete e[h], k(e), T(), a.fadeOut(f.trashSpeed), l = !1 } function I(e, r, n, t) { ne(f.onDragStart) && !1 === f.onDragStart(e, r, _(c), p) || (l = !0, u = r, d = "spare" === (h = e) ? "offboard" : e, function () { for (var e in w = {}, g) g.hasOwnProperty(e) && (w[e] = z("#" + g[e]).offset()) }(), a.attr("src", P(r)).css({ display: "", position: "absolute", left: n - b / 2, top: t - b / 2 }), "spare" !== e && z("#" + g[e]).addClass(H.highlight1).find("." + H.piece).css("display", "none")) } function M(e, r) { a.css({ left: e - b / 2, top: r - b / 2 }); var n = E(e, r); n !== d && (oe(d) && z("#" + g[d]).removeClass(H.highlight2), oe(n) && z("#" + g[n]).addClass(H.highlight2), ne(f.onDragMove) && f.onDragMove(n, d, h, u, _(c), p), d = n) } function N(e) { var r = "drop"; if ("offboard" === e && "snapback" === f.dropOffBoard && (r = "snapback"), "offboard" === e && "trash" === f.dropOffBoard && (r = "trash"), ne(f.onDrop)) { var n = _(c); "spare" === h && oe(e) && (n[e] = u), oe(h) && "offboard" === e && delete n[h], oe(h) && oe(e) && (delete n[h], n[e] = u); var t = _(c), o = f.onDrop(h, e, u, n, t, p); "snapback" !== o && "trash" !== o || (r = o) } "snapback" === r ? function () { if ("spare" !== h) { C(); var e = z("#" + g[h]).offset(), r = { duration: f.snapbackSpeed, complete: function () { T(), a.css("display", "none"), ne(f.onSnapbackEnd) && f.onSnapbackEnd(u, h, _(c), p) } }; a.animate(e, r), l = !1 } else B() }() : "trash" === r ? B() : "drop" === r && function (e) { C(); var r = _(c); delete r[h], r[e] = u, k(r); var n = z("#" + g[e]).offset(), t = { duration: f.snapSpeed, complete: function () { T(), a.css("display", "none"), ne(f.onSnapEnd) && f.onSnapEnd(h, e, u) } }; a.animate(n, t), l = !1 }(e) } function j(e) { e.preventDefault() } function D(e) { if (f.draggable) { var r = z(this).attr("data-square"); oe(r) && c.hasOwnProperty(r) && I(r, c[r], e.pageX, e.pageY) } } function R(e) { if (f.draggable) { var r = z(this).attr("data-square"); oe(r) && c.hasOwnProperty(r) && (e = e.originalEvent, I(r, c[r], e.changedTouches[0].pageX, e.changedTouches[0].pageY)) } } function Q(e) { f.sparePieces && I("spare", z(this).attr("data-piece"), e.pageX, e.pageY) } function X(e) { f.sparePieces && I("spare", z(this).attr("data-piece"), (e = e.originalEvent).changedTouches[0].pageX, e.changedTouches[0].pageY) } i.clear = function (e) { i.position({}, e) }, i.destroy = function () { n.html(""), a.remove(), n.unbind() }, i.fen = function () { return i.position("fen") }, i.flip = function () { return i.orientation("flip") }, i.move = function () { if (0 !== arguments.length) { for (var e = !0, r = {}, n = 0; n < arguments.length; n++)if (!1 !== arguments[n]) if (te(arguments[n])) { var t = arguments[n].split("-"); r[t[0]] = t[1] } else m(2826, "Invalid move passed to the move method.", arguments[n]); else e = !1; var o = function (e, r) { var n = _(e); for (var t in r) if (r.hasOwnProperty(t) && n.hasOwnProperty(t)) { var o = n[t]; delete n[t], n[r[t]] = o } return n }(c, r); return i.position(o, e), o } }, i.orientation = function (e) { return 0 === arguments.length ? p : "white" === e || "black" === e ? (p = e, q(), p) : "flip" === e ? (p = "white" === p ? "black" : "white", q(), p) : void m(5482, "Invalid value passed to the orientation method.", e) }, i.position = function (e, r) { if (0 === arguments.length) return _(c); if (re(e) && "fen" === e.toLowerCase()) return ce(c); (re(e) && "start" === e.toLowerCase() && (e = _(G)), ae(e) && (e = pe(e)), ie(e)) ? (!1 !== r && (r = !0), r ? (function (e, r, n) { if (0 !== e.length) for (var t = 0, o = 0; o < e.length; o++) { var a = e[o]; "clear" === a.type ? z("#" + g[a.square] + " ." + H.piece).fadeOut(f.trashSpeed, i) : "add" !== a.type || f.sparePieces ? "add" === a.type && f.sparePieces ? S(a.piece, a.square, i) : "move" === a.type && O(a.source, a.destination, a.piece, i) : z("#" + g[a.square]).append(y(a.piece, !0)).find("." + H.piece).fadeIn(f.appearSpeed, i) } function i() { (t += 1) === e.length && (T(), ne(f.onMoveEnd) && f.onMoveEnd(_(r), _(n))) } }(function (e, r) { e = _(e), r = _(r); var n = [], t = {}; for (var o in r) r.hasOwnProperty(o) && e.hasOwnProperty(o) && e[o] === r[o] && (delete e[o], delete r[o]); for (o in r) if (r.hasOwnProperty(o)) { var a = ue(e, r[o], o); a && (n.push({ type: "move", source: a, destination: o, piece: r[o] }), delete e[a], delete r[o], t[o] = !0) } for (o in r) r.hasOwnProperty(o) && (n.push({ type: "add", square: o, piece: r[o] }), delete r[o]); for (o in e) e.hasOwnProperty(o) && (t.hasOwnProperty(o) || (n.push({ type: "clear", square: o, piece: e[o] }), delete e[o])); return n }(c, e), c, e), k(e)) : (k(e), T())) : m(6482, "Invalid value passed to the position method.", e) }, i.resize = function () { b = function () { var e = parseInt(n.width(), 10); if (!e || e <= 0) return 0; for (var r = e - 1; r % 8 != 0 && 0 < r;)r -= 1; return r / 8 }(), r.css("width", 8 * b + "px"), a.css({ height: b, width: b }), f.sparePieces && n.find("." + H.sparePieces).css("paddingLeft", b + s + "px"), q() }, i.start = function (e) { i.position("start", e) }; var Y = V(function (e) { l && M(e.pageX, e.pageY) }, f.dragThrottleRate), K = V(function (e) { l && (e.preventDefault(), M(e.originalEvent.changedTouches[0].pageX, e.originalEvent.changedTouches[0].pageY)) }, f.dragThrottleRate); function L(e) { l && N(E(e.pageX, e.pageY)) } function U(e) { l && N(E(e.originalEvent.changedTouches[0].pageX, e.originalEvent.changedTouches[0].pageY)) } function $(e) { if (!l && ne(f.onMouseoverSquare)) { var r = z(e.currentTarget).attr("data-square"); if (oe(r)) { var n = !1; c.hasOwnProperty(r) && (n = c[r]), f.onMouseoverSquare(r, n, _(c), p) } } } function J(e) { if (!l && ne(f.onMouseoutSquare)) { var r = z(e.currentTarget).attr("data-square"); if (oe(r)) { var n = !1; c.hasOwnProperty(r) && (n = c[r]), f.onMouseoutSquare(r, n, _(c), p) } } } return p = f.orientation, f.hasOwnProperty("position") && ("start" === f.position ? c = _(G) : ae(f.position) ? c = pe(f.position) : ie(f.position) ? c = _(f.position) : m(7263, "Invalid value passed to config.position.", f.position)), function () { !function () { for (var e = 0; e < F.length; e++)for (var r = 1; r <= 8; r++) { var n = F[e] + r; g[n] = n + "-" + Z() } var t = "KQRNBP".split(""); for (e = 0; e < t.length; e++) { var o = "w" + t[e], a = "b" + t[e]; v[o] = o + "-" + Z(), v[a] = a + "-" + Z() } }(), n.html(function (e) { var r = '<div class="{chessboard}">'; return e && (r += '<div class="{sparePieces} {sparePiecesTop}"></div>'), r += '<div class="{board}"></div>', e && (r += '<div class="{sparePieces} {sparePiecesBottom}"></div>'), ee(r += "</div>", H) }(f.sparePieces)), r = n.find("." + H.board), f.sparePieces && (t = n.find("." + H.sparePiecesTop), o = n.find("." + H.sparePiecesBottom)); var e = Z(); z("body").append(y("wP", !0, e)), a = z("#" + e), s = parseInt(r.css("borderLeftWidth"), 10), i.resize() }(), function () { z("body").on("mousedown mousemove", "." + H.piece, j), r.on("mousedown", "." + H.square, D), n.on("mousedown", "." + H.sparePieces + " ." + H.piece, Q), r.on("mouseenter", "." + H.square, $).on("mouseleave", "." + H.square, J); var e = z(window); e.on("mousemove", Y).on("mouseup", L), "ontouchstart" in document.documentElement && (r.on("touchstart", "." + H.square, R), n.on("touchstart", "." + H.sparePieces + " ." + H.piece, X), e.on("touchmove", K).on("touchend", U)) }(), i }, window.ChessBoard = window.Chessboard, window.Chessboard.fenToObj = pe, window.Chessboard.objToFen = ce }();
	</script>

	<script>
		/*
		 * Copyright (c) 2016, Jeff Hlywa (jhlywa@gmail.com)
		 * All rights reserved.
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are met:
		 *
		 * 1. Redistributions of source code must retain the above copyright notice,
		 *    this list of conditions and the following disclaimer.
		 * 2. Redistributions in binary form must reproduce the above copyright notice,
		 *    this list of conditions and the following disclaimer in the documentation
		 *    and/or other materials provided with the distribution.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
		 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
		 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
		 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
		 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
		 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
		 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
		 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
		 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
		 * POSSIBILITY OF SUCH DAMAGE.
		 *
		 *----------------------------------------------------------------------------*/

		/* minified license below  */

		/* @license
		 * Copyright (c) 2016, Jeff Hlywa (jhlywa@gmail.com)
		 * Released under the BSD license
		 * https://github.com/jhlywa/chess.js/blob/master/LICENSE
		 */

		var Chess = function (fen) {

			/* jshint indent: false */

			var BLACK = 'b';
			var WHITE = 'w';

			var EMPTY = -1;

			var PAWN = 'p';
			var KNIGHT = 'n';
			var BISHOP = 'b';
			var ROOK = 'r';
			var QUEEN = 'q';
			var KING = 'k';

			var SYMBOLS = 'pnbrqkPNBRQK';

			var DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

			var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*'];

			var PAWN_OFFSETS = {
				b: [16, 32, 17, 15],
				w: [-16, -32, -17, -15]
			};

			var PIECE_OFFSETS = {
				n: [-18, -33, -31, -14, 18, 33, 31, 14],
				b: [-17, -15, 17, 15],
				r: [-16, 1, 16, -1],
				q: [-17, -16, -15, 1, 17, 16, 15, -1],
				k: [-17, -16, -15, 1, 17, 16, 15, -1]
			};

			var ATTACKS = [
				20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,
				0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,
				0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,
				0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,
				0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
				24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,
				0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,
				0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,
				0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,
				0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,
				20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20
			];

			var RAYS = [
				17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,
				0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,
				0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,
				0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,
				0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,
				1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,
				0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,
				0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,
				0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,
				0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,
				-15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17
			];

			var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 };

			var FLAGS = {
				NORMAL: 'n',
				CAPTURE: 'c',
				BIG_PAWN: 'b',
				EP_CAPTURE: 'e',
				PROMOTION: 'p',
				KSIDE_CASTLE: 'k',
				QSIDE_CASTLE: 'q'
			};

			var BITS = {
				NORMAL: 1,
				CAPTURE: 2,
				BIG_PAWN: 4,
				EP_CAPTURE: 8,
				PROMOTION: 16,
				KSIDE_CASTLE: 32,
				QSIDE_CASTLE: 64
			};

			var RANK_1 = 7;
			var RANK_2 = 6;
			var RANK_3 = 5;
			var RANK_4 = 4;
			var RANK_5 = 3;
			var RANK_6 = 2;
			var RANK_7 = 1;
			var RANK_8 = 0;

			var SQUARES = {
				a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,
				a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,
				a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,
				a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,
				a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,
				a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,
				a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,
				a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
			};

			var ROOKS = {
				w: [{ square: SQUARES.a1, flag: BITS.QSIDE_CASTLE },
				{ square: SQUARES.h1, flag: BITS.KSIDE_CASTLE }],
				b: [{ square: SQUARES.a8, flag: BITS.QSIDE_CASTLE },
				{ square: SQUARES.h8, flag: BITS.KSIDE_CASTLE }]
			};

			var board = new Array(128);
			var kings = { w: EMPTY, b: EMPTY };
			var turn = WHITE;
			var castling = { w: 0, b: 0 };
			var ep_square = EMPTY;
			var half_moves = 0;
			var move_number = 1;
			var history = [];
			var header = {};

			/* if the user passes in a fen string, load it, else default to
			 * starting position
			 */
			if (typeof fen === 'undefined') {
				load(DEFAULT_POSITION);
			} else {
				load(fen);
			}

			function clear() {
				board = new Array(128);
				kings = { w: EMPTY, b: EMPTY };
				turn = WHITE;
				castling = { w: 0, b: 0 };
				ep_square = EMPTY;
				half_moves = 0;
				move_number = 1;
				history = [];
				header = {};
				update_setup(generate_fen());
			}

			function reset() {
				load(DEFAULT_POSITION);
			}

			function load(fen) {
				var tokens = fen.split(/\s+/);
				var position = tokens[0];
				var square = 0;

				if (!validate_fen(fen).valid) {
					return false;
				}

				clear();

				for (var i = 0; i < position.length; i++) {
					var piece = position.charAt(i);

					if (piece === '/') {
						square += 8;
					} else if (is_digit(piece)) {
						square += parseInt(piece, 10);
					} else {
						var color = (piece < 'a') ? WHITE : BLACK;
						put({ type: piece.toLowerCase(), color: color }, algebraic(square));
						square++;
					}
				}

				turn = tokens[1];

				if (tokens[2].indexOf('K') > -1) {
					castling.w |= BITS.KSIDE_CASTLE;
				}
				if (tokens[2].indexOf('Q') > -1) {
					castling.w |= BITS.QSIDE_CASTLE;
				}
				if (tokens[2].indexOf('k') > -1) {
					castling.b |= BITS.KSIDE_CASTLE;
				}
				if (tokens[2].indexOf('q') > -1) {
					castling.b |= BITS.QSIDE_CASTLE;
				}

				ep_square = (tokens[3] === '-') ? EMPTY : SQUARES[tokens[3]];
				half_moves = parseInt(tokens[4], 10);
				move_number = parseInt(tokens[5], 10);

				update_setup(generate_fen());

				return true;
			}

			/* TODO: this function is pretty much crap - it validates structure but
			 * completely ignores content (e.g. doesn't verify that each side has a king)
			 * ... we should rewrite this, and ditch the silly error_number field while
			 * we're at it
			 */
			function validate_fen(fen) {
				var errors = {
					0: 'No errors.',
					1: 'FEN string must contain six space-delimited fields.',
					2: '6th field (move number) must be a positive integer.',
					3: '5th field (half move counter) must be a non-negative integer.',
					4: '4th field (en-passant square) is invalid.',
					5: '3rd field (castling availability) is invalid.',
					6: '2nd field (side to move) is invalid.',
					7: '1st field (piece positions) does not contain 8 \'/\'-delimited rows.',
					8: '1st field (piece positions) is invalid [consecutive numbers].',
					9: '1st field (piece positions) is invalid [invalid piece].',
					10: '1st field (piece positions) is invalid [row too large].',
					11: 'Illegal en-passant square',
				};

				/* 1st criterion: 6 space-seperated fields? */
				var tokens = fen.split(/\s+/);
				if (tokens.length !== 6) {
					return { valid: false, error_number: 1, error: errors[1] };
				}

				/* 2nd criterion: move number field is a integer value > 0? */
				if (isNaN(tokens[5]) || (parseInt(tokens[5], 10) <= 0)) {
					return { valid: false, error_number: 2, error: errors[2] };
				}

				/* 3rd criterion: half move counter is an integer >= 0? */
				if (isNaN(tokens[4]) || (parseInt(tokens[4], 10) < 0)) {
					return { valid: false, error_number: 3, error: errors[3] };
				}

				/* 4th criterion: 4th field is a valid e.p.-string? */
				if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {
					return { valid: false, error_number: 4, error: errors[4] };
				}

				/* 5th criterion: 3th field is a valid castle-string? */
				if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {
					return { valid: false, error_number: 5, error: errors[5] };
				}

				/* 6th criterion: 2nd field is "w" (white) or "b" (black)? */
				if (!/^(w|b)$/.test(tokens[1])) {
					return { valid: false, error_number: 6, error: errors[6] };
				}

				/* 7th criterion: 1st field contains 8 rows? */
				var rows = tokens[0].split('/');
				if (rows.length !== 8) {
					return { valid: false, error_number: 7, error: errors[7] };
				}

				/* 8th criterion: every row is valid? */
				for (var i = 0; i < rows.length; i++) {
					/* check for right sum of fields AND not two numbers in succession */
					var sum_fields = 0;
					var previous_was_number = false;

					for (var k = 0; k < rows[i].length; k++) {
						if (!isNaN(rows[i][k])) {
							if (previous_was_number) {
								return { valid: false, error_number: 8, error: errors[8] };
							}
							sum_fields += parseInt(rows[i][k], 10);
							previous_was_number = true;
						} else {
							if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {
								return { valid: false, error_number: 9, error: errors[9] };
							}
							sum_fields += 1;
							previous_was_number = false;
						}
					}
					if (sum_fields !== 8) {
						return { valid: false, error_number: 10, error: errors[10] };
					}
				}

				if ((tokens[3][1] == '3' && tokens[1] == 'w') ||
					(tokens[3][1] == '6' && tokens[1] == 'b')) {
					return { valid: false, error_number: 11, error: errors[11] };
				}

				/* everything's okay! */
				return { valid: true, error_number: 0, error: errors[0] };
			}

			function generate_fen() {
				var empty = 0;
				var fen = '';

				for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
					if (board[i] == null) {
						empty++;
					} else {
						if (empty > 0) {
							fen += empty;
							empty = 0;
						}
						var color = board[i].color;
						var piece = board[i].type;

						fen += (color === WHITE) ?
							piece.toUpperCase() : piece.toLowerCase();
					}

					if ((i + 1) & 0x88) {
						if (empty > 0) {
							fen += empty;
						}

						if (i !== SQUARES.h1) {
							fen += '/';
						}

						empty = 0;
						i += 8;
					}
				}

				var cflags = '';
				if (castling[WHITE] & BITS.KSIDE_CASTLE) { cflags += 'K'; }
				if (castling[WHITE] & BITS.QSIDE_CASTLE) { cflags += 'Q'; }
				if (castling[BLACK] & BITS.KSIDE_CASTLE) { cflags += 'k'; }
				if (castling[BLACK] & BITS.QSIDE_CASTLE) { cflags += 'q'; }

				/* do we have an empty castling flag? */
				cflags = cflags || '-';
				var epflags = (ep_square === EMPTY) ? '-' : algebraic(ep_square);

				return [fen, turn, cflags, epflags, half_moves, move_number].join(' ');
			}

			function set_header(args) {
				for (var i = 0; i < args.length; i += 2) {
					if (typeof args[i] === 'string' &&
						typeof args[i + 1] === 'string') {
						header[args[i]] = args[i + 1];
					}
				}
				return header;
			}

			/* called when the initial board setup is changed with put() or remove().
			 * modifies the SetUp and FEN properties of the header object.  if the FEN is
			 * equal to the default position, the SetUp and FEN are deleted
			 * the setup is only updated if history.length is zero, ie moves haven't been
			 * made.
			 */
			function update_setup(fen) {
				if (history.length > 0) return;

				if (fen !== DEFAULT_POSITION) {
					header['SetUp'] = '1';
					header['FEN'] = fen;
				} else {
					delete header['SetUp'];
					delete header['FEN'];
				}
			}

			function get(square) {
				var piece = board[SQUARES[square]];
				return (piece) ? { type: piece.type, color: piece.color } : null;
			}

			function put(piece, square) {
				/* check for valid piece object */
				if (!('type' in piece && 'color' in piece)) {
					return false;
				}

				/* check for piece */
				if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {
					return false;
				}

				/* check for valid square */
				if (!(square in SQUARES)) {
					return false;
				}

				var sq = SQUARES[square];

				/* don't let the user place more than one king */
				if (piece.type == KING &&
					!(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {
					return false;
				}

				board[sq] = { type: piece.type, color: piece.color };
				if (piece.type === KING) {
					kings[piece.color] = sq;
				}

				update_setup(generate_fen());

				return true;
			}

			function remove(square) {
				var piece = get(square);
				board[SQUARES[square]] = null;
				if (piece && piece.type === KING) {
					kings[piece.color] = EMPTY;
				}

				update_setup(generate_fen());

				return piece;
			}

			function build_move(board, from, to, flags, promotion) {
				var move = {
					color: turn,
					from: from,
					to: to,
					flags: flags,
					piece: board[from].type
				};

				if (promotion) {
					move.flags |= BITS.PROMOTION;
					move.promotion = promotion;
				}

				if (board[to]) {
					move.captured = board[to].type;
				} else if (flags & BITS.EP_CAPTURE) {
					move.captured = PAWN;
				}
				return move;
			}

			function generate_moves(options) {
				function add_move(board, moves, from, to, flags) {
					/* if pawn promotion */
					if (board[from].type === PAWN &&
						(rank(to) === RANK_8 || rank(to) === RANK_1)) {
						var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];
						for (var i = 0, len = pieces.length; i < len; i++) {
							moves.push(build_move(board, from, to, flags, pieces[i]));
						}
					} else {
						moves.push(build_move(board, from, to, flags));
					}
				}

				var moves = [];
				var us = turn;
				var them = swap_color(us);
				var second_rank = { b: RANK_7, w: RANK_2 };

				var first_sq = SQUARES.a8;
				var last_sq = SQUARES.h1;
				var single_square = false;

				/* do we want legal moves? */
				var legal = (typeof options !== 'undefined' && 'legal' in options) ?
					options.legal : true;

				/* are we generating moves for a single square? */
				if (typeof options !== 'undefined' && 'square' in options) {
					if (options.square in SQUARES) {
						first_sq = last_sq = SQUARES[options.square];
						single_square = true;
					} else {
						/* invalid square */
						return [];
					}
				}

				for (var i = first_sq; i <= last_sq; i++) {
					/* did we run off the end of the board */
					if (i & 0x88) { i += 7; continue; }

					var piece = board[i];
					if (piece == null || piece.color !== us) {
						continue;
					}

					if (piece.type === PAWN) {
						/* single square, non-capturing */
						var square = i + PAWN_OFFSETS[us][0];
						if (board[square] == null) {
							add_move(board, moves, i, square, BITS.NORMAL);

							/* double square */
							var square = i + PAWN_OFFSETS[us][1];
							if (second_rank[us] === rank(i) && board[square] == null) {
								add_move(board, moves, i, square, BITS.BIG_PAWN);
							}
						}

						/* pawn captures */
						for (j = 2; j < 4; j++) {
							var square = i + PAWN_OFFSETS[us][j];
							if (square & 0x88) continue;

							if (board[square] != null &&
								board[square].color === them) {
								add_move(board, moves, i, square, BITS.CAPTURE);
							} else if (square === ep_square) {
								add_move(board, moves, i, ep_square, BITS.EP_CAPTURE);
							}
						}
					} else {
						for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {
							var offset = PIECE_OFFSETS[piece.type][j];
							var square = i;

							while (true) {
								square += offset;
								if (square & 0x88) break;

								if (board[square] == null) {
									add_move(board, moves, i, square, BITS.NORMAL);
								} else {
									if (board[square].color === us) break;
									add_move(board, moves, i, square, BITS.CAPTURE);
									break;
								}

								/* break, if knight or king */
								if (piece.type === 'n' || piece.type === 'k') break;
							}
						}
					}
				}

				/* check for castling if: a) we're generating all moves, or b) we're doing
				 * single square move generation on the king's square
				 */
				if ((!single_square) || last_sq === kings[us]) {
					/* king-side castling */
					if (castling[us] & BITS.KSIDE_CASTLE) {
						var castling_from = kings[us];
						var castling_to = castling_from + 2;

						if (board[castling_from + 1] == null &&
							board[castling_to] == null &&
							!attacked(them, kings[us]) &&
							!attacked(them, castling_from + 1) &&
							!attacked(them, castling_to)) {
							add_move(board, moves, kings[us], castling_to,
								BITS.KSIDE_CASTLE);
						}
					}

					/* queen-side castling */
					if (castling[us] & BITS.QSIDE_CASTLE) {
						var castling_from = kings[us];
						var castling_to = castling_from - 2;

						if (board[castling_from - 1] == null &&
							board[castling_from - 2] == null &&
							board[castling_from - 3] == null &&
							!attacked(them, kings[us]) &&
							!attacked(them, castling_from - 1) &&
							!attacked(them, castling_to)) {
							add_move(board, moves, kings[us], castling_to,
								BITS.QSIDE_CASTLE);
						}
					}
				}

				/* return all pseudo-legal moves (this includes moves that allow the king
				 * to be captured)
				 */
				if (!legal) {
					return moves;
				}

				/* filter out illegal moves */
				var legal_moves = [];
				for (var i = 0, len = moves.length; i < len; i++) {
					make_move(moves[i]);
					if (!king_attacked(us)) {
						legal_moves.push(moves[i]);
					}
					undo_move();
				}

				return legal_moves;
			}

			/* convert a move from 0x88 coordinates to Standard Algebraic Notation
			 * (SAN)
			 *
			 * @param {boolean} sloppy Use the sloppy SAN generator to work around over
			 * disambiguation bugs in Fritz and Chessbase.  See below:
			 *
			 * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4
			 * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned
			 * 4. ... Ne7 is technically the valid SAN
			 */
			function move_to_san(move, sloppy) {

				var output = '';

				if (move.flags & BITS.KSIDE_CASTLE) {
					output = 'O-O';
				} else if (move.flags & BITS.QSIDE_CASTLE) {
					output = 'O-O-O';
				} else {
					var disambiguator = get_disambiguator(move, sloppy);

					if (move.piece !== PAWN) {
						output += move.piece.toUpperCase() + disambiguator;
					}

					if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
						if (move.piece === PAWN) {
							output += algebraic(move.from)[0];
						}
						output += 'x';
					}

					output += algebraic(move.to);

					if (move.flags & BITS.PROMOTION) {
						output += '=' + move.promotion.toUpperCase();
					}
				}

				make_move(move);
				if (in_check()) {
					if (in_checkmate()) {
						output += '#';
					} else {
						output += '+';
					}
				}
				undo_move();

				return output;
			}

			// parses all of the decorators out of a SAN string
			function stripped_san(move) {
				return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');
			}

			function attacked(color, square) {
				for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
					/* did we run off the end of the board */
					if (i & 0x88) { i += 7; continue; }

					/* if empty square or wrong color */
					if (board[i] == null || board[i].color !== color) continue;

					var piece = board[i];
					var difference = i - square;
					var index = difference + 119;

					if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {
						if (piece.type === PAWN) {
							if (difference > 0) {
								if (piece.color === WHITE) return true;
							} else {
								if (piece.color === BLACK) return true;
							}
							continue;
						}

						/* if the piece is a knight or a king */
						if (piece.type === 'n' || piece.type === 'k') return true;

						var offset = RAYS[index];
						var j = i + offset;

						var blocked = false;
						while (j !== square) {
							if (board[j] != null) { blocked = true; break; }
							j += offset;
						}

						if (!blocked) return true;
					}
				}

				return false;
			}

			function king_attacked(color) {
				return attacked(swap_color(color), kings[color]);
			}

			function in_check() {
				return king_attacked(turn);
			}

			function in_checkmate() {
				return in_check() && generate_moves().length === 0;
			}

			function in_stalemate() {
				return !in_check() && generate_moves().length === 0;
			}

			function insufficient_material() {
				var pieces = {};
				var bishops = [];
				var num_pieces = 0;
				var sq_color = 0;

				for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
					sq_color = (sq_color + 1) % 2;
					if (i & 0x88) { i += 7; continue; }

					var piece = board[i];
					if (piece) {
						pieces[piece.type] = (piece.type in pieces) ?
							pieces[piece.type] + 1 : 1;
						if (piece.type === BISHOP) {
							bishops.push(sq_color);
						}
						num_pieces++;
					}
				}

				/* k vs. k */
				if (num_pieces === 2) { return true; }

				/* k vs. kn .... or .... k vs. kb */
				else if (num_pieces === 3 && (pieces[BISHOP] === 1 ||
					pieces[KNIGHT] === 1)) { return true; }

				/* kb vs. kb where any number of bishops are all on the same color */
				else if (num_pieces === pieces[BISHOP] + 2) {
					var sum = 0;
					var len = bishops.length;
					for (var i = 0; i < len; i++) {
						sum += bishops[i];
					}
					if (sum === 0 || sum === len) { return true; }
				}

				return false;
			}

			function in_threefold_repetition() {
				/* TODO: while this function is fine for casual use, a better
				 * implementation would use a Zobrist key (instead of FEN). the
				 * Zobrist key would be maintained in the make_move/undo_move functions,
				 * avoiding the costly that we do below.
				 */
				var moves = [];
				var positions = {};
				var repetition = false;

				while (true) {
					var move = undo_move();
					if (!move) break;
					moves.push(move);
				}

				while (true) {
					/* remove the last two fields in the FEN string, they're not needed
					 * when checking for draw by rep */
					var fen = generate_fen().split(' ').slice(0, 4).join(' ');

					/* has the position occurred three or move times */
					positions[fen] = (fen in positions) ? positions[fen] + 1 : 1;
					if (positions[fen] >= 3) {
						repetition = true;
					}

					if (!moves.length) {
						break;
					}
					make_move(moves.pop());
				}

				return repetition;
			}

			function push(move) {
				history.push({
					move: move,
					kings: { b: kings.b, w: kings.w },
					turn: turn,
					castling: { b: castling.b, w: castling.w },
					ep_square: ep_square,
					half_moves: half_moves,
					move_number: move_number
				});
			}

			function make_move(move) {
				var us = turn;
				var them = swap_color(us);
				push(move);

				board[move.to] = board[move.from];
				board[move.from] = null;

				/* if ep capture, remove the captured pawn */
				if (move.flags & BITS.EP_CAPTURE) {
					if (turn === BLACK) {
						board[move.to - 16] = null;
					} else {
						board[move.to + 16] = null;
					}
				}

				/* if pawn promotion, replace with new piece */
				if (move.flags & BITS.PROMOTION) {
					board[move.to] = { type: move.promotion, color: us };
				}

				/* if we moved the king */
				if (board[move.to].type === KING) {
					kings[board[move.to].color] = move.to;

					/* if we castled, move the rook next to the king */
					if (move.flags & BITS.KSIDE_CASTLE) {
						var castling_to = move.to - 1;
						var castling_from = move.to + 1;
						board[castling_to] = board[castling_from];
						board[castling_from] = null;
					} else if (move.flags & BITS.QSIDE_CASTLE) {
						var castling_to = move.to + 1;
						var castling_from = move.to - 2;
						board[castling_to] = board[castling_from];
						board[castling_from] = null;
					}

					/* turn off castling */
					castling[us] = '';
				}

				/* turn off castling if we move a rook */
				if (castling[us]) {
					for (var i = 0, len = ROOKS[us].length; i < len; i++) {
						if (move.from === ROOKS[us][i].square &&
							castling[us] & ROOKS[us][i].flag) {
							castling[us] ^= ROOKS[us][i].flag;
							break;
						}
					}
				}

				/* turn off castling if we capture a rook */
				if (castling[them]) {
					for (var i = 0, len = ROOKS[them].length; i < len; i++) {
						if (move.to === ROOKS[them][i].square &&
							castling[them] & ROOKS[them][i].flag) {
							castling[them] ^= ROOKS[them][i].flag;
							break;
						}
					}
				}

				/* if big pawn move, update the en passant square */
				if (move.flags & BITS.BIG_PAWN) {
					if (turn === 'b') {
						ep_square = move.to - 16;
					} else {
						ep_square = move.to + 16;
					}
				} else {
					ep_square = EMPTY;
				}

				/* reset the 50 move counter if a pawn is moved or a piece is captured */
				if (move.piece === PAWN) {
					half_moves = 0;
				} else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
					half_moves = 0;
				} else {
					half_moves++;
				}

				if (turn === BLACK) {
					move_number++;
				}
				turn = swap_color(turn);
			}

			function undo_move() {
				var old = history.pop();
				if (old == null) { return null; }

				var move = old.move;
				kings = old.kings;
				turn = old.turn;
				castling = old.castling;
				ep_square = old.ep_square;
				half_moves = old.half_moves;
				move_number = old.move_number;

				var us = turn;
				var them = swap_color(turn);

				board[move.from] = board[move.to];
				board[move.from].type = move.piece;  // to undo any promotions
				board[move.to] = null;

				if (move.flags & BITS.CAPTURE) {
					board[move.to] = { type: move.captured, color: them };
				} else if (move.flags & BITS.EP_CAPTURE) {
					var index;
					if (us === BLACK) {
						index = move.to - 16;
					} else {
						index = move.to + 16;
					}
					board[index] = { type: PAWN, color: them };
				}


				if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {
					var castling_to, castling_from;
					if (move.flags & BITS.KSIDE_CASTLE) {
						castling_to = move.to + 1;
						castling_from = move.to - 1;
					} else if (move.flags & BITS.QSIDE_CASTLE) {
						castling_to = move.to - 2;
						castling_from = move.to + 1;
					}

					board[castling_to] = board[castling_from];
					board[castling_from] = null;
				}

				return move;
			}

			/* this function is used to uniquely identify ambiguous moves */
			function get_disambiguator(move, sloppy) {
				var moves = generate_moves({ legal: !sloppy });

				var from = move.from;
				var to = move.to;
				var piece = move.piece;

				var ambiguities = 0;
				var same_rank = 0;
				var same_file = 0;

				for (var i = 0, len = moves.length; i < len; i++) {
					var ambig_from = moves[i].from;
					var ambig_to = moves[i].to;
					var ambig_piece = moves[i].piece;

					/* if a move of the same piece type ends on the same to square, we'll
					 * need to add a disambiguator to the algebraic notation
					 */
					if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {
						ambiguities++;

						if (rank(from) === rank(ambig_from)) {
							same_rank++;
						}

						if (file(from) === file(ambig_from)) {
							same_file++;
						}
					}
				}

				if (ambiguities > 0) {
					/* if there exists a similar moving piece on the same rank and file as
					 * the move in question, use the square as the disambiguator
					 */
					if (same_rank > 0 && same_file > 0) {
						return algebraic(from);
					}
					/* if the moving piece rests on the same file, use the rank symbol as the
					 * disambiguator
					 */
					else if (same_file > 0) {
						return algebraic(from).charAt(1);
					}
					/* else use the file symbol */
					else {
						return algebraic(from).charAt(0);
					}
				}

				return '';
			}

			function ascii() {
				var s = '   +------------------------+\n';
				for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
					/* display the rank */
					if (file(i) === 0) {
						s += ' ' + '87654321'[rank(i)] + ' |';
					}

					/* empty piece */
					if (board[i] == null) {
						s += ' . ';
					} else {
						var piece = board[i].type;
						var color = board[i].color;
						var symbol = (color === WHITE) ?
							piece.toUpperCase() : piece.toLowerCase();
						s += ' ' + symbol + ' ';
					}

					if ((i + 1) & 0x88) {
						s += '|\n';
						i += 8;
					}
				}
				s += '   +------------------------+\n';
				s += '     a  b  c  d  e  f  g  h\n';

				return s;
			}

			// convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates
			function move_from_san(move, sloppy) {
				// strip off any move decorations: e.g Nf3+?!
				var clean_move = stripped_san(move);

				// if we're using the sloppy parser run a regex to grab piece, to, and from
				// this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7
				if (sloppy) {
					var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);
					if (matches) {
						var piece = matches[1];
						var from = matches[2];
						var to = matches[3];
						var promotion = matches[4];
					}
				}

				var moves = generate_moves();
				for (var i = 0, len = moves.length; i < len; i++) {
					// try the strict parser first, then the sloppy parser if requested
					// by the user
					if ((clean_move === stripped_san(move_to_san(moves[i]))) ||
						(sloppy && clean_move === stripped_san(move_to_san(moves[i], true)))) {
						return moves[i];
					} else {
						if (matches &&
							(!piece || piece.toLowerCase() == moves[i].piece) &&
							SQUARES[from] == moves[i].from &&
							SQUARES[to] == moves[i].to &&
							(!promotion || promotion.toLowerCase() == moves[i].promotion)) {
							return moves[i];
						}
					}
				}

				return null;
			}


			/*****************************************************************************
			 * UTILITY FUNCTIONS
			 ****************************************************************************/
			function rank(i) {
				return i >> 4;
			}

			function file(i) {
				return i & 15;
			}

			function algebraic(i) {
				var f = file(i), r = rank(i);
				return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);
			}

			function swap_color(c) {
				return c === WHITE ? BLACK : WHITE;
			}

			function is_digit(c) {
				return '0123456789'.indexOf(c) !== -1;
			}

			/* pretty = external move object */
			function make_pretty(ugly_move) {
				var move = clone(ugly_move);
				move.san = move_to_san(move, false);
				move.to = algebraic(move.to);
				move.from = algebraic(move.from);

				var flags = '';

				for (var flag in BITS) {
					if (BITS[flag] & move.flags) {
						flags += FLAGS[flag];
					}
				}
				move.flags = flags;

				return move;
			}

			function clone(obj) {
				var dupe = (obj instanceof Array) ? [] : {};

				for (var property in obj) {
					if (typeof property === 'object') {
						dupe[property] = clone(obj[property]);
					} else {
						dupe[property] = obj[property];
					}
				}

				return dupe;
			}

			function trim(str) {
				return str.replace(/^\s+|\s+$/g, '');
			}

			/*****************************************************************************
			 * DEBUGGING UTILITIES
			 ****************************************************************************/
			function perft(depth) {
				var moves = generate_moves({ legal: false });
				var nodes = 0;
				var color = turn;

				for (var i = 0, len = moves.length; i < len; i++) {
					make_move(moves[i]);
					if (!king_attacked(color)) {
						if (depth - 1 > 0) {
							var child_nodes = perft(depth - 1);
							nodes += child_nodes;
						} else {
							nodes++;
						}
					}
					undo_move();
				}

				return nodes;
			}

			return {
				/***************************************************************************
				 * PUBLIC CONSTANTS (is there a better way to do this?)
				 **************************************************************************/
				WHITE: WHITE,
				BLACK: BLACK,
				PAWN: PAWN,
				KNIGHT: KNIGHT,
				BISHOP: BISHOP,
				ROOK: ROOK,
				QUEEN: QUEEN,
				KING: KING,
				SQUARES: (function () {
					/* from the ECMA-262 spec (section 12.6.4):
					 * "The mechanics of enumerating the properties ... is
					 * implementation dependent"
					 * so: for (var sq in SQUARES) { keys.push(sq); } might not be
					 * ordered correctly
					 */
					var keys = [];
					for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
						if (i & 0x88) { i += 7; continue; }
						keys.push(algebraic(i));
					}
					return keys;
				})(),
				FLAGS: FLAGS,

				/***************************************************************************
				 * PUBLIC API
				 **************************************************************************/
				load: function (fen) {
					return load(fen);
				},

				reset: function () {
					return reset();
				},

				moves: function (options) {
					/* The internal representation of a chess move is in 0x88 format, and
					 * not meant to be human-readable.  The code below converts the 0x88
					 * square coordinates to algebraic coordinates.  It also prunes an
					 * unnecessary move keys resulting from a verbose call.
					 */

					var ugly_moves = generate_moves(options);
					var moves = [];

					for (var i = 0, len = ugly_moves.length; i < len; i++) {

						/* does the user want a full move object (most likely not), or just
						 * SAN
						 */
						if (typeof options !== 'undefined' && 'verbose' in options &&
							options.verbose) {
							moves.push(make_pretty(ugly_moves[i]));
						} else {
							moves.push(move_to_san(ugly_moves[i], false));
						}
					}

					return moves;
				},

				in_check: function () {
					return in_check();
				},

				in_checkmate: function () {
					return in_checkmate();
				},

				in_stalemate: function () {
					return in_stalemate();
				},

				in_draw: function () {
					return half_moves >= 100 ||
						in_stalemate() ||
						insufficient_material() ||
						in_threefold_repetition();
				},

				insufficient_material: function () {
					return insufficient_material();
				},

				in_threefold_repetition: function () {
					return in_threefold_repetition();
				},

				game_over: function () {
					return half_moves >= 100 ||
						in_checkmate() ||
						in_stalemate() ||
						insufficient_material() ||
						in_threefold_repetition();
				},

				validate_fen: function (fen) {
					return validate_fen(fen);
				},

				fen: function () {
					return generate_fen();
				},

				pgn: function (options) {
					/* using the specification from http://www.chessclub.com/help/PGN-spec
					 * example for html usage: .pgn({ max_width: 72, newline_char: "<br />" })
					 */
					var newline = (typeof options === 'object' &&
						typeof options.newline_char === 'string') ?
						options.newline_char : '\n';
					var max_width = (typeof options === 'object' &&
						typeof options.max_width === 'number') ?
						options.max_width : 0;
					var result = [];
					var header_exists = false;

					/* add the PGN header headerrmation */
					for (var i in header) {
						/* TODO: order of enumerated properties in header object is not
						 * guaranteed, see ECMA-262 spec (section 12.6.4)
						 */
						result.push('[' + i + ' \"' + header[i] + '\"]' + newline);
						header_exists = true;
					}

					if (header_exists && history.length) {
						result.push(newline);
					}

					/* pop all of history onto reversed_history */
					var reversed_history = [];
					while (history.length > 0) {
						reversed_history.push(undo_move());
					}

					var moves = [];
					var move_string = '';

					/* build the list of moves.  a move_string looks like: "3. e3 e6" */
					while (reversed_history.length > 0) {
						var move = reversed_history.pop();

						/* if the position started with black to move, start PGN with 1. ... */
						if (!history.length && move.color === 'b') {
							move_string = move_number + '. ...';
						} else if (move.color === 'w') {
							/* store the previous generated move_string if we have one */
							if (move_string.length) {
								moves.push(move_string);
							}
							move_string = move_number + '.';
						}

						move_string = move_string + ' ' + move_to_san(move, false);
						make_move(move);
					}

					/* are there any other leftover moves? */
					if (move_string.length) {
						moves.push(move_string);
					}

					/* is there a result? */
					if (typeof header.Result !== 'undefined') {
						moves.push(header.Result);
					}

					/* history should be back to what is was before we started generating PGN,
					 * so join together moves
					 */
					if (max_width === 0) {
						return result.join('') + moves.join(' ');
					}

					/* wrap the PGN output at max_width */
					var current_width = 0;
					for (var i = 0; i < moves.length; i++) {
						/* if the current move will push past max_width */
						if (current_width + moves[i].length > max_width && i !== 0) {

							/* don't end the line with whitespace */
							if (result[result.length - 1] === ' ') {
								result.pop();
							}

							result.push(newline);
							current_width = 0;
						} else if (i !== 0) {
							result.push(' ');
							current_width++;
						}
						result.push(moves[i]);
						current_width += moves[i].length;
					}

					return result.join('');
				},

				load_pgn: function (pgn, options) {
					// allow the user to specify the sloppy move parser to work around over
					// disambiguation bugs in Fritz and Chessbase
					var sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?
						options.sloppy : false;

					function mask(str) {
						return str.replace(/\\/g, '\\');
					}

					function has_keys(object) {
						for (var key in object) {
							return true;
						}
						return false;
					}

					function parse_pgn_header(header, options) {
						var newline_char = (typeof options === 'object' &&
							typeof options.newline_char === 'string') ?
							options.newline_char : '\r?\n';
						var header_obj = {};
						var headers = header.split(new RegExp(mask(newline_char)));
						var key = '';
						var value = '';

						for (var i = 0; i < headers.length; i++) {
							key = headers[i].replace(/^\[([A-Z][A-Za-z]*)\s.*\]$/, '$1');
							value = headers[i].replace(/^\[[A-Za-z]+\s"(.*)"\]$/, '$1');
							if (trim(key).length > 0) {
								header_obj[key] = value;
							}
						}

						return header_obj;
					}

					var newline_char = (typeof options === 'object' &&
						typeof options.newline_char === 'string') ?
						options.newline_char : '\r?\n';
					var regex = new RegExp('^(\\[(.|' + mask(newline_char) + ')*\\])' +
						'(' + mask(newline_char) + ')*' +
						'1.(' + mask(newline_char) + '|.)*$', 'g');

					/* get header part of the PGN file */
					var header_string = pgn.replace(regex, '$1');

					/* no info part given, begins with moves */
					if (header_string[0] !== '[') {
						header_string = '';
					}

					reset();

					/* parse PGN header */
					var headers = parse_pgn_header(header_string, options);
					for (var key in headers) {
						set_header([key, headers[key]]);
					}

					/* load the starting position indicated by [Setup '1'] and
					* [FEN position] */
					if (headers['SetUp'] === '1') {
						if (!(('FEN' in headers) && load(headers['FEN']))) {
							return false;
						}
					}

					/* delete header to get the moves */
					var ms = pgn.replace(header_string, '').replace(new RegExp(mask(newline_char), 'g'), ' ');

					/* delete comments */
					ms = ms.replace(/(\{[^}]+\})+?/g, '');

					/* delete recursive annotation variations */
					var rav_regex = /(\([^\(\)]+\))+?/g
					while (rav_regex.test(ms)) {
						ms = ms.replace(rav_regex, '');
					}

					/* delete move numbers */
					ms = ms.replace(/\d+\.(\.\.)?/g, '');

					/* delete ... indicating black to move */
					ms = ms.replace(/\.\.\./g, '');

					/* delete numeric annotation glyphs */
					ms = ms.replace(/\$\d+/g, '');

					/* trim and get array of moves */
					var moves = trim(ms).split(new RegExp(/\s+/));

					/* delete empty entries */
					moves = moves.join(',').replace(/,,+/g, ',').split(',');
					var move = '';

					for (var half_move = 0; half_move < moves.length - 1; half_move++) {
						move = move_from_san(moves[half_move], sloppy);

						/* move not possible! (don't clear the board to examine to show the
						 * latest valid position)
						 */
						if (move == null) {
							return false;
						} else {
							make_move(move);
						}
					}

					/* examine last move */
					move = moves[moves.length - 1];
					if (POSSIBLE_RESULTS.indexOf(move) > -1) {
						if (has_keys(header) && typeof header.Result === 'undefined') {
							set_header(['Result', move]);
						}
					}
					else {
						move = move_from_san(move, sloppy);
						if (move == null) {
							return false;
						} else {
							make_move(move);
						}
					}
					return true;
				},

				header: function () {
					return set_header(arguments);
				},

				ascii: function () {
					return ascii();
				},

				turn: function () {
					return turn;
				},

				move: function (move, options) {
					/* The move function can be called with in the following parameters:
					 *
					 * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string
					 *
					 * .move({ from: 'h7', <- where the 'move' is a move object (additional
					 *         to :'h8',      fields are ignored)
					 *         promotion: 'q',
					 *      })
					 */

					// allow the user to specify the sloppy move parser to work around over
					// disambiguation bugs in Fritz and Chessbase
					var sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?
						options.sloppy : false;

					var move_obj = null;

					if (typeof move === 'string') {
						move_obj = move_from_san(move, sloppy);
					} else if (typeof move === 'object') {
						var moves = generate_moves();

						/* convert the pretty move object to an ugly move object */
						for (var i = 0, len = moves.length; i < len; i++) {
							if (move.from === algebraic(moves[i].from) &&
								move.to === algebraic(moves[i].to) &&
								(!('promotion' in moves[i]) ||
									move.promotion === moves[i].promotion)) {
								move_obj = moves[i];
								break;
							}
						}
					}

					/* failed to find move */
					if (!move_obj) {
						return null;
					}

					/* need to make a copy of move because we can't generate SAN after the
					 * move is made
					 */
					var pretty_move = make_pretty(move_obj);

					make_move(move_obj);

					return pretty_move;
				},

				undo: function () {
					var move = undo_move();
					return (move) ? make_pretty(move) : null;
				},

				clear: function () {
					return clear();
				},

				put: function (piece, square) {
					return put(piece, square);
				},

				get: function (square) {
					return get(square);
				},

				remove: function (square) {
					return remove(square);
				},

				perft: function (depth) {
					return perft(depth);
				},

				square_color: function (square) {
					if (square in SQUARES) {
						var sq_0x88 = SQUARES[square];
						return ((rank(sq_0x88) + file(sq_0x88)) % 2 === 0) ? 'light' : 'dark';
					}

					return null;
				},

				history: function (options) {
					var reversed_history = [];
					var move_history = [];
					var verbose = (typeof options !== 'undefined' && 'verbose' in options &&
						options.verbose);

					while (history.length > 0) {
						reversed_history.push(undo_move());
					}

					while (reversed_history.length > 0) {
						var move = reversed_history.pop();
						if (verbose) {
							move_history.push(make_pretty(move));
						} else {
							move_history.push(move_to_san(move));
						}
						make_move(move);
					}

					return move_history;
				}

			};
		};

		/* export Chess object if using node or any other CommonJS compatible
		 * environment */
		if (typeof exports !== 'undefined') exports.Chess = Chess;
		/* export Chess object for any RequireJS compatible environment */
		if (typeof define !== 'undefined') define(function () { return Chess; });

	</script>

	<style>
		/*! chessboard.js v1.0.0 | (c) 2019 Chris Oakman | MIT License chessboardjs.com/license */
		.clearfix-7da63 {
			clear: both
		}

		.board-b72b1 {
			box-sizing: content-box
		}

		.square-55d63 {
			float: left;
			position: relative;
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none
		}

		.white-1e1d7 {
			background-color: #f0d9b5;
			color: #b58863
		}

		.black-3c85d {
			background-color: #b58863;
			color: #f0d9b5
		}

		.highlight1-32417,
		.highlight2-9c5d2 {
			box-shadow: inset 0 0 3px 3px #ff0
		}

		.notation-322f9 {
			cursor: default;
			font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
			font-size: 14px;
			position: absolute
		}

		.alpha-d2270 {
			bottom: 1px;
			right: 3px
		}

		.numeric-fc462 {
			top: 2px;
			left: 2px
		}

		body {
			margin: 0;
			text-align: center;
			font-size: 3vmin;

		}

		@media only screen and (orientation: landscape) {
			body {
				font-size: 2vmin;
			}
		}


		button {
			font-size: 1.2em;
			margin: 5px;
			margin-top: 0.4em;
			margin-bottom: 0.4em;
			background-color: #f5f5f5 !important;
			background-image: -webkit-linear-gradient(top, #f5f5f5, #f1f1f1) !important;
			color: #333B45 !important;
			border: 1px solid #dcdcdc;
			-webkit-border-radius: 2px;
			border-radius: 2px;
			cursor: default;
			font-weight: bold;
			text-align: center;
			text-decoration: none;
		}

		#center {
			text-align: center;
			margin: 0.5em;
		}

		button:hover {
			background-color: #F8F8F8 !important;
			background-image: -webkit-linear-gradient(top, #f8f8f8, #f1f1f1);
			border: 1px solid #C6C6C6;
			color: #333;
			-webkit-box-shadow: 0px 1px 1px rgba(0, 0, 0, .1);
			box-shadow: 0px 1px 1px rgba(0, 0, 0, .1);
		}

		button:focus {
			outline: 0;
		}

		/* Popup container - can be anything you want */
		.popup {
			position: relative;
			display: inline-block;
			cursor: pointer;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}

		/* The actual popup */
		.popup .popuptext {
			visibility: hidden;
			width: 10em;
			background-color: #555;
			color: #fff;
			text-align: center;
			border-radius: 6px;
			padding: 8px 0;
			position: absolute;
			z-index: 1;
			bottom: -4em;
			margin-left: -6.3em;
		}


		/* Toggle this class - hide and show the popup */
		.popup .show {
			visibility: visible;
			-webkit-animation: fadeIn 1s;
			animation: fadeIn 0.3s;
		}

		/* Add animation (fade in the popup) */
		@-webkit-keyframes fadeIn {
			from {
				opacity: 0;
			}

			to {
				opacity: 1;
			}
		}

		@keyframes fadeIn {
			from {
				opacity: 0;
			}

			to {
				opacity: 1;
			}
		}


		::-webkit-scrollbar {
			display: none;
		}

		#boardCommentsContainer {
			width: 100vw;
		}

		#board {
			border: 0.7vmin solid #670A0A;
			background-color: #670A0A;
			border-right: 0;
			border-radius: 4px;

			width: 97vw;
			max-width: 600px;
			display: inline-block;
			vertical-align: middle;
			margin: 0 auto;
		}

		#commentSection2 {
			padding: 0.5em;
			border-top-right-radius: 4px;
			border-top-left-radius: 4px;
		}

		#commentSection {

			padding: 0.5em;
			border-bottom-right-radius: 4px;
			border-bottom-left-radius: 4px;
		}

		#commentContainer {
			display: inline-block;
			font-size: 15px;
			border: 3px solid LightGray;
			border-radius: 7px;
			width: 92vw;
			max-width: 600px;
			margin: 0 auto;
		}

		@media only screen and (orientation: landscape) {

			#center {
				width: 60vw;
				display: inline-block;
				max-width: 94vh;
				vertical-align: top
			}

			#board {

				width: 60vw;
				max-width: 91vh;
			}

			#commentContainer {
				width: 30vw;
				max-width: 300px;
				display: inline-block;
				vertical-align: top;
				margin-top: 3.9em;
				float: none;

			}
		}



		a:link,
		a:visited {
			color: inherit;

			text-decoration: none;
			display: inline-block;
		}

		#commentSection>img,
		#commentSection2>img {
			border-radius: 10px;
			border: 4px solid;
			background-color: white;
			max-height: 95%;
			max-width: 90%;
		}
	</style>

</head>

<body>


	<script>



		function getUrlVars() {
			var vars = {};
			var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {
				vars[key] = decodeURI(value);
			});
			return vars;
		}

		function swapColorsMain(head)
		{
			for(let i =0;i < head.length; i++)
			{
				head[i].turn = head[i].turn == "w" ? "b" : "w";
				if(head[i].variations.length > 0)
				{
					for(let j =0;j<head[i].variations.length;j++)
					{
						swapColorsMain(head[i].variations[j]);
					}
				}
			}
		}

		var pgn = getUrlVars()["PGN"];
		var CommentsField = getUrlVars()["Comments"];
		var TitleField = getUrlVars()["Title"];
		var playerMakesFirstMove;
		if(getUrlVars()["FirstMove"])
		{
			playerMakesFirstMove = getUrlVars()["FirstMove"]== "true";
		}
		else
		{
			playerMakesFirstMove = false;
		}
		var acceptPlayerVariations;
		if(getUrlVars()["AcceptPlayerVariations"])
		{
			acceptPlayerVariations = getUrlVars()["AcceptPlayerVariations"]== "true";
		}
		else
		{
			acceptPlayerVariations = false;
			
		}
		var correctVariation = true;

		let parsedPGN = parsePgn(pgn, { startRule: "game" });

		var fen;

		if (getUrlVars()["FEN"]) {
			fen = decodeURI(getUrlVars()["FEN"]);
		} else {
			fen = parsedPGN.tags.FEN
		}



		var boardRotation = playerMakesFirstMove ? "white" : "black";

		var FEN = fen;


		var patt = /(( b | w ))(?!.*\1)/g;
		var result = FEN.match(patt);
		if (result == " b ") {

			boardRotation = playerMakesFirstMove ? "black": "white" ;

		}
		if((boardRotation == "black" && playerMakesFirstMove) || (boardRotation == "white" && !playerMakesFirstMove))
		{
			swapColorsMain(parsedPGN.moves);
			console.log(parsedPGN)
		}

	</script>

	<div id="boardCommentsContainer">

		<div id="center">

			<button title="open in Lichess Analysis Board"><a id="lichess">Lichess</button>
			<button class="reveal" title="reset"
				onclick="loadBoard();document.getElementById('board').style.backgroundColor = '#670A0A';document.getElementById('board').style.borderColor = '#670A0A';">&#128260;</button>

			<div title="Choose Default Promotion" class="popup" onclick="myFunction()"><img src="_wQ.svg"
					id=promotButton
					style="width: 2em; height: 2em; border: 1px solid #dcdcdc; border-radius:3px; background-color: #f5f5f5; margin-bottom:-0.6em">
				<span class="popuptext" id="myPopup">
					<img src="_wQ.svg" style="width: 2em; height: 2em;"
						onclick="promoteChoice='q';document.getElementById('promotButton').src='_wQ.svg'">
					<img src="_wB.svg" style="width: 2em; height: 2em;"
						onclick="promoteChoice='b';document.getElementById('promotButton').src='_wB.svg'">
					<img src="_wN.svg" style="width: 2em; height: 2em;"
						onclick="promoteChoice='n';document.getElementById('promotButton').src='_wN.svg'">
					<img src="_wR.svg" style="width: 2em; height: 2em;"
						onclick="promoteChoice='r';document.getElementById('promotButton').src='_wR.svg'">
				</span>
			</div>

			<button title="copy current FEN position"
				onclick="document.getElementById('fenReveal').style.display = 'block'; document.getElementById('fenReveal').value = fen_position;copyFen(); document.getElementById('fenReveal').style.display = 'none'">FEN</button>

			<div id='board'></div>
		</div>


		<div id="commentContainer">


			<div id='commentSection2'>Opponent Comments</div>
			<div id='commentSection'>Player Comments</div>
		</div>
		<div>




			<script>
				const matchesMediaQuery = window.matchMedia('(orientation:landscape)').matches;


				// dymically prevent board from going above 600px
				if (matchesMediaQuery) {
					if (document.getElementById("board").offsetWidth > 600) {
						document.getElementById("board").style.width = "600px";
						document.getElementById("center").style.width = "600px";
					}
				}

				// hide the comments bar if not needed
				if (!pgn.includes("{") && !getUrlVars()["Comments"] && !getUrlVars()["Title"]) {
					document.getElementById("commentContainer").style.display = "none";
				}

				if (boardRotation === "white") {
					document.getElementById("commentSection").style.backgroundColor = "white";
					document.getElementById("commentSection2").style.backgroundColor = "black";
					document.getElementById("commentSection2").style.color = "White";
				} else {
					document.getElementById("commentSection2").style.backgroundColor = "white";
					document.getElementById("commentSection").style.backgroundColor = "black";
					document.getElementById("commentSection").style.color = "White";
				}







				//prevent scroling on toutch screen when dragging pieces
				var fixed = document.getElementById('board');

				fixed.addEventListener('touchmove', function (e) {

					e.preventDefault();

				}, false);
			</script>










			<input type="text" id=fenReveal style="display:none">
			<script>
				document.getElementById("lichess").href = "https://lichess.org/analysis/" + FEN + "";


				// When the user clicks on div, open the popup
				function myFunction() {
					var popup = document.getElementById("myPopup");
					popup.classList.toggle("show");
				}
			</script>

			<script type="text/javascript">

				function copyFen() {
					/* Get the text field */
					var copyText = document.getElementById("fenReveal");

					/* Select the text field */
					copyText.select();
					copyText.setSelectionRange(0, 99999); /* For mobile devices */

					/* Copy the text inside the text field */
					document.execCommand("copy");

				}

			</script>




			<script>
				var count = 0; // Int so we can track on which move we are.
				var fen_position = FEN; //setup inital fen
				var fen_position0 = FEN; //save start Fen value
				var expectedLine = parsedPGN.moves; // Set initially to the mainline of pgn but can change path with variations
				var expectedMove = parsedPGN.moves[count]; // Set the expected move according to PGN
				var variationStack = [];
				var variationNum = [];
				var promoteChoice = 'q'; //default promotion to queen, can be changed with button withing template however it must be specified before move is made.
				var foundVariation; // a bullion to check if there are multiple lines
				var responseVar; // used to randomly sellect an appropriate response
			</script>

			<script>



				function pieceTheme(piece) {
					// wikipedia theme for white pieces
					if (piece.search(/w/) !== -1) {
						return '_' + piece + '.svg';
					}

					return '_' + piece + '.svg';
				}

				var board,
					game = new Chess();

				game.load(fen_position);

				game.move(expectedLine[0].notation.notation);




				// do not pick up pieces if the game is over
				// only pick up pieces for the side to move
				var onDragStart = function (source, piece, position, orientation) {





					if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
						(game.turn() === 'b' && piece.search(/^w/) !== -1)) {
						return false;
					}
				};

				//
				// This function triggers when the player
				// releases a piece.
				//
				var onDrop = function (source, target) {


					var move = game.move({
						from: source,
						to: target,
						promotion: promoteChoice
					});








					// First Check If Valid Move

					if (move === null) {

						return 'snapback'

					}

					// Check to see if attempted move is valid (including alternate lines)
					// alternate line branching only supported by current player to simplify code

					// check alternate line first
					if (move.san !== expectedMove.notation.notation && acceptPlayerVariations) {
						if (expectedMove.variations.length > 0) {
							foundVariation = false;
							correctVariation = false;
							for (var i = 0; i < expectedMove.variations.length; i++) {
								if (move.san === expectedMove.variations[i][0].notation.notation) {
									count = 0;
									expectedLine = expectedMove.variations[i];
									expectedMove = expectedLine[count];
									if (expectedMove.commentAfter) {
										document.getElementById("commentSection").innerHTML = expectedMove.commentAfter;
									}
									count++;
									expectedMove = expectedLine[count];
									if (expectedMove && expectedMove.notation) { //check to see if there is a valid next move otherwise there will be no response

										if (expectedMove.variations.length > 0) { //check for variations and play a random response
											variationNum.push(0);
											variationStack.push([expectedLine, game.fen(), count]);
											count = 0;
											expectedLine = expectedMove.variations[0];
											expectedMove = expectedLine[0];

										}

										game.move(expectedMove.notation.notation);
										if (expectedMove.commentAfter) {
											document.getElementById("commentSection2").innerHTML = expectedMove.commentAfter;
										}
										count++;
										expectedMove = expectedLine[count];
									}
									else if (variationStack.length > 0) {
										//Es gab irgendwo eine Variation
										variationNum[variationStack.length - 1]++;

										expectedLine = variationStack[variationStack.length - 1][0];
										game.load(variationStack[variationStack.length - 1][1]);
										count = variationStack[variationStack.length - 1][2];

										if (variationNum[variationStack.length - 1] < variationStack[variationStack.length - 1][0][count].variations.length) {
											expectedLine = expectedLine[count].variations[variationNum[variationStack.length - 1]];
											count = 0;
										}
										else {
											variationStack.pop();
											variationNum.pop();
										}

										expectedMove = expectedLine[count];
										game.move(expectedMove.notation.notation);
										if (expectedMove.commentAfter) {
											document.getElementById("commentSection2").innerHTML = expectedMove.commentAfter;
										}
										count++;
										expectedMove = expectedLine[count];

									}
									fen_position = game.fen(); // Store the current position.
									foundVariation = true;

									break
								}

							}

							// wrong move
							if (foundVariation === false) { //check to see if there is a valid next move otherwise there will be no response
								// Snapback for some reason doesn't work properly here...
								game.load(fen_position);
								return 'snapback';
							}

						} else {
							// Snapback for some reason doesn't work properly here...
							game.load(fen_position);
							return 'snapback';
						}


					} else if (move.san === expectedMove.notation.notation) {
						if (expectedMove.commentAfter) {
							document.getElementById("commentSection").innerHTML = expectedMove.commentAfter;
						}
						count++;
						expectedMove = expectedLine[count];
						if (expectedMove && expectedMove.notation) { //check to see if there is a valid next move otherwise there will be no response

							if (expectedMove.variations.length > 0) { //check for variations and play a random response
								variationNum.push(0);
								variationStack.push([expectedLine, game.fen(), count]);
								count = 0;
								expectedLine = expectedMove.variations[0];
								expectedMove = expectedLine[0];

							}
							game.move(expectedMove.notation.notation);
							if (expectedMove.commentAfter) {
								document.getElementById("commentSection2").innerHTML = expectedMove.commentAfter;
							}
							count++;
							expectedMove = expectedLine[count];
						}
						else if (variationStack.length > 0) {
							//Es gab irgendwo eine Variation
							variationNum[variationStack.length - 1]++;

							expectedLine = variationStack[variationStack.length - 1][0];
							game.load(variationStack[variationStack.length - 1][1]);
							count = variationStack[variationStack.length - 1][2];

							if (variationNum[variationStack.length - 1] < variationStack[variationStack.length - 1][0][count].variations.length) {
								expectedLine = expectedLine[count].variations[variationNum[variationStack.length - 1]];
								count = 0;
							}
							else {
								variationStack.pop();
								variationNum.pop();
							}

							expectedMove = expectedLine[count];
							game.move(expectedMove.notation.notation);
							if (expectedMove.commentAfter) {
								document.getElementById("commentSection2").innerHTML = expectedMove.commentAfter;
							}
							count++;
							expectedMove = expectedLine[count];

						}


						fen_position = game.fen(); // Store the current position.


					}
					else
					{
						game.undo();
						return 'snapback'
					}

				};

				// update the board position after the piece snap
				// for castling, en passant, pawn promotion
				var onSnapEnd = function () {
					board.position(game.fen());
					if (!expectedMove || !expectedMove.notation) { //check for valid move after played move ie. if puzzle is solved
						var configEnd = {
							position: fen_position,
							orientation: boardRotation
						}
						if(correctVariation)
						{
							document.getElementById('board').style.backgroundColor = 'limegreen'; document.getElementById('board').style.borderColor = 'limegreen'
						}

						setTimeout(function () {
							board = Chessboard('board', configEnd)

						}, 200);


					}
				};



				var cfg = {
					orientation: boardRotation,
					draggable: true,
					position: fen_position0,
					onDragStart: onDragStart,
					onDrop: onDrop,
					onSnapEnd: onSnapEnd
				};


				function loadBoard() {

					board = ChessBoard('board', cfg);
					game.load(fen_position0);
					if(!playerMakesFirstMove)
					{
						game.move(parsedPGN.moves[0].notation.notation);
					}
					setTimeout(function () {

						fen_position = game.fen();
						board.position(fen_position);

					}, 300);


					count = playerMakesFirstMove ? 0 : 1;
					correctVariation = true;
					expectedLine = parsedPGN.moves;
					expectedMove = parsedPGN.moves[count];
					document.getElementById('commentSection').innerHTML = 'Player Comments';
					document.getElementById('commentSection2').innerHTML = 'Opponent Comments';
					if (getUrlVars()["Comments"]) {
						document.getElementById('commentSection').innerHTML = CommentsField;
					}
					if (getUrlVars()["Title"]) {
						document.getElementById('commentSection2').innerHTML = TitleField;
					}
					if (parsedPGN.moves[0].commentAfter) {
						document.getElementById("commentSection2").innerHTML = parsedPGN.moves[0].commentAfter;
					}
				}

				loadBoard();




			</script>




</body>

</html>